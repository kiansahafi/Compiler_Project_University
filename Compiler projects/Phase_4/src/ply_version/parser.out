Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHAR
    DO
    FOR
    MAIN
    PLUSASSIGN

Grammar

Rule 0     S' -> start
Rule 1     start -> ClassDeclaration
Rule 2     start -> empty
Rule 3     start -> exp
Rule 4     ClassDeclaration -> CLASS IDENTIFIER LBRACE RBRACE
Rule 5     ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE
Rule 6     ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE
Rule 7     FieldDeclaration -> Declarators IDENTIFIER SEMICOLON
Rule 8     MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE
Rule 9     MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
Rule 10    MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
Rule 11    MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE
Rule 12    ParameterList -> Type IDENTIFIER
Rule 13    ParameterList -> Type IDENTIFIER COMMA Type IDENTIFIER
Rule 14    Declarators -> Type
Rule 15    Declarators -> STATIC Type
Rule 16    Declarators -> PUBLIC Type
Rule 17    Declarators -> PRIVATE Type
Rule 18    Declarators -> PUBLIC STATIC Type
Rule 19    Declarators -> PRIVATE STATIC Type
Rule 20    Type -> PrimeType
Rule 21    Type -> ClassType
Rule 22    Type -> arraytype
Rule 23    PrimeType -> INT
Rule 24    PrimeType -> BOOLEAN
Rule 25    PrimeType -> VOID
Rule 26    PrimeType -> FLOAT
Rule 27    ClassType -> IDENTIFIER
Rule 28    arraytype -> INT LBRACKET RBRACKET
Rule 29    arraytype -> ClassType LBRACKET RBRACKET
Rule 30    argumentlist -> exp
Rule 31    argumentlist -> exp COMMA exp
Rule 32    Refrence -> THIS
Rule 33    Refrence -> IDENTIFIER
Rule 34    statement -> empty
Rule 35    statement -> if_st
Rule 36    statement -> while_st
Rule 37    statement -> LBRACE statement RBRACE
Rule 38    statement -> Refrence LPAREN argumentlist RPAREN
Rule 39    statement -> Refrence LPAREN RPAREN SEMICOLON
Rule 40    statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
Rule 41    statement -> Refrence ASSIGN exp SEMICOLON
Rule 42    statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
Rule 43    statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON
Rule 44    statement -> statement statement
Rule 45    statement -> exp
Rule 46    while_st -> WHILE LPAREN exp RPAREN statement
Rule 47    if_st -> IF LPAREN exp RPAREN statement ELSE statement
Rule 48    if_st -> IF LPAREN exp RPAREN statement
Rule 49    exp -> <empty>
Rule 50    exp -> exp Binop exp
Rule 51    exp -> IDENTIFIER
Rule 52    exp -> Type exp
Rule 53    exp -> Refrence LBRACKET exp RBRACKET
Rule 54    exp -> Refrence LPAREN RPAREN
Rule 55    exp -> Refrence LPAREN argumentlist RPAREN
Rule 56    exp -> Unop exp
Rule 57    exp -> LPAREN exp RPAREN
Rule 58    exp -> TRUE
Rule 59    exp -> IDENTIFIER Binop NUMBER
Rule 60    exp -> FALSE
Rule 61    exp -> NEW IDENTIFIER LPAREN RPAREN
Rule 62    exp -> NEW INT LBRACKET exp RBRACKET
Rule 63    exp -> NEW IDENTIFIER LBRACKET exp RBRACKET
Rule 64    exp -> NUMBER Binop NUMBER
Rule 65    exp -> NUMBER Binop float
Rule 66    exp -> float Binop NUMBER
Rule 67    exp -> float Binop float
Rule 68    Unop -> NOT
Rule 69    Unop -> MINUS
Rule 70    float -> NUMBER COMMA NUMBER
Rule 71    Binop -> PLUS
Rule 72    Binop -> MINUS
Rule 73    Binop -> TIMES
Rule 74    Binop -> DIVIDE
Rule 75    Binop -> EQ
Rule 76    Binop -> NOT_EQ
Rule 77    Binop -> LT
Rule 78    Binop -> GT
Rule 79    Binop -> LE
Rule 80    Binop -> GE
Rule 81    Binop -> AND
Rule 82    Binop -> NOT
Rule 83    empty -> <empty>

Terminals, with rules where they appear

AND                  : 81
ASSIGN               : 40 41 42 43
BOOLEAN              : 24
CHAR                 : 
CLASS                : 4 5 6
COMMA                : 13 31 70
DIVIDE               : 74
DO                   : 
ELSE                 : 47
EQ                   : 75
FALSE                : 60
FLOAT                : 26
FOR                  : 
GE                   : 80
GT                   : 78
IDENTIFIER           : 4 5 6 7 8 9 10 11 12 13 13 27 33 42 42 43 51 59 61 63
IF                   : 47 48
INT                  : 23 28 62
LBRACE               : 4 5 6 8 9 10 11 37
LBRACKET             : 28 29 40 53 62 63
LE                   : 79
LPAREN               : 8 9 10 11 38 39 46 47 48 54 55 57 61
LT                   : 77
MAIN                 : 
MINUS                : 69 72
NEW                  : 61 62 63
NOT                  : 68 82
NOT_EQ               : 76
NUMBER               : 59 64 64 65 66 70 70
PLUS                 : 71
PLUSASSIGN           : 
PRIVATE              : 17 19
PUBLIC               : 16 18
RBRACE               : 4 5 6 8 9 10 11 37
RBRACKET             : 28 29 40 53 62 63
RETURN               : 9 10
RPAREN               : 8 9 10 11 38 39 46 47 48 54 55 57 61
SEMICOLON            : 7 9 10 39 40 41 42 43
STATIC               : 15 18 19
THIS                 : 32
TIMES                : 73
TRUE                 : 58
VOID                 : 25
WHILE                : 46
error                : 

Nonterminals, with rules where they appear

Binop                : 50 59 64 65 66 67
ClassDeclaration     : 1
ClassType            : 21 29
Declarators          : 7 8 9 10 11
FieldDeclaration     : 6
MethodDeclaration    : 5
ParameterList        : 10 11
PrimeType            : 20 42 43
Refrence             : 38 39 40 41 53 54 55
Type                 : 12 13 13 14 15 16 17 18 19 52
Unop                 : 56
argumentlist         : 38 55
arraytype            : 22
empty                : 2 34
exp                  : 3 9 10 30 31 31 40 40 41 43 45 46 47 48 50 50 52 53 56 57 62 63
float                : 65 66 67 67
if_st                : 35
start                : 0
statement            : 8 9 10 11 37 44 44 46 47 47 48
while_st             : 36

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . ClassDeclaration
    (2) start -> . empty
    (3) start -> . exp
    (4) ClassDeclaration -> . CLASS IDENTIFIER LBRACE RBRACE
    (5) ClassDeclaration -> . CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE
    (6) ClassDeclaration -> . CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE
    (83) empty -> .
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! reduce/reduce conflict for $end resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    CLASS           shift and go to state 5
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    $end            reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! $end            [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    start                          shift and go to state 1
    ClassDeclaration               shift and go to state 2
    empty                          shift and go to state 3
    exp                            shift and go to state 4
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 1

    (0) S' -> start .



state 2

    (1) start -> ClassDeclaration .

    $end            reduce using rule 1 (start -> ClassDeclaration .)


state 3

    (2) start -> empty .

    $end            reduce using rule 2 (start -> empty .)


state 4

    (3) start -> exp .
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    $end            reduce using rule 3 (start -> exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 5

    (4) ClassDeclaration -> CLASS . IDENTIFIER LBRACE RBRACE
    (5) ClassDeclaration -> CLASS . IDENTIFIER LBRACE MethodDeclaration RBRACE
    (6) ClassDeclaration -> CLASS . IDENTIFIER LBRACE FieldDeclaration RBRACE

    IDENTIFIER      shift and go to state 39


state 6

    (51) exp -> IDENTIFIER .
    (59) exp -> IDENTIFIER . Binop NUMBER
    (33) Refrence -> IDENTIFIER .
    (27) ClassType -> IDENTIFIER .
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

  ! reduce/reduce conflict for LPAREN resolved using rule 33 (Refrence -> IDENTIFIER .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for TRUE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for FALSE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NEW resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NUMBER resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for THIS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for INT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for VOID resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for EQ resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for GT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for GE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for RETURN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    LBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (ClassType -> IDENTIFIER .)
    LPAREN          reduce using rule 27 (ClassType -> IDENTIFIER .)
    TRUE            reduce using rule 27 (ClassType -> IDENTIFIER .)
    FALSE           reduce using rule 27 (ClassType -> IDENTIFIER .)
    NEW             reduce using rule 27 (ClassType -> IDENTIFIER .)
    NUMBER          reduce using rule 27 (ClassType -> IDENTIFIER .)
    THIS            reduce using rule 27 (ClassType -> IDENTIFIER .)
    INT             reduce using rule 27 (ClassType -> IDENTIFIER .)
    BOOLEAN         reduce using rule 27 (ClassType -> IDENTIFIER .)
    VOID            reduce using rule 27 (ClassType -> IDENTIFIER .)
    FLOAT           reduce using rule 27 (ClassType -> IDENTIFIER .)
    $end            reduce using rule 27 (ClassType -> IDENTIFIER .)
    RPAREN          reduce using rule 27 (ClassType -> IDENTIFIER .)
    RBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    COMMA           reduce using rule 27 (ClassType -> IDENTIFIER .)
    RBRACE          reduce using rule 27 (ClassType -> IDENTIFIER .)
    RETURN          reduce using rule 27 (ClassType -> IDENTIFIER .)
    LBRACE          reduce using rule 27 (ClassType -> IDENTIFIER .)
    IF              reduce using rule 27 (ClassType -> IDENTIFIER .)
    WHILE           reduce using rule 27 (ClassType -> IDENTIFIER .)
    ELSE            reduce using rule 27 (ClassType -> IDENTIFIER .)
    SEMICOLON       reduce using rule 27 (ClassType -> IDENTIFIER .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

  ! PLUS            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! EQ              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NOT_EQ          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LT              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! GT              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LE              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! GE              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! $end            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! RPAREN          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! RBRACKET        [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! RBRACE          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! RETURN          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! THIS            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! INT             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! BOOLEAN         [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! VOID            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! FLOAT           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! TRUE            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! FALSE           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NEW             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NUMBER          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! SEMICOLON       [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LBRACKET        [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! EQ              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! NOT_EQ          [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! LT              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! GT              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! LE              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! GE              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]

    Binop                          shift and go to state 40

state 7

    (52) exp -> Type . exp
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    $end            reduce using rule 49 (exp -> .)
    RPAREN          reduce using rule 49 (exp -> .)
    RBRACKET        reduce using rule 49 (exp -> .)
    COMMA           reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    LBRACE          reduce using rule 49 (exp -> .)
    IF              reduce using rule 49 (exp -> .)
    WHILE           reduce using rule 49 (exp -> .)
    ELSE            reduce using rule 49 (exp -> .)
    SEMICOLON       reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    Type                           shift and go to state 7
    exp                            shift and go to state 41
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 8

    (53) exp -> Refrence . LBRACKET exp RBRACKET
    (54) exp -> Refrence . LPAREN RPAREN
    (55) exp -> Refrence . LPAREN argumentlist RPAREN

    LBRACKET        shift and go to state 42
    LPAREN          shift and go to state 43


state 9

    (57) exp -> LPAREN . exp RPAREN
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RPAREN          reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 44
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 10

    (56) exp -> Unop . exp
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    $end            reduce using rule 49 (exp -> .)
    RPAREN          reduce using rule 49 (exp -> .)
    RBRACKET        reduce using rule 49 (exp -> .)
    COMMA           reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    LBRACE          reduce using rule 49 (exp -> .)
    IF              reduce using rule 49 (exp -> .)
    WHILE           reduce using rule 49 (exp -> .)
    ELSE            reduce using rule 49 (exp -> .)
    SEMICOLON       reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    Unop                           shift and go to state 10
    exp                            shift and go to state 45
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 11

    (58) exp -> TRUE .

    PLUS            reduce using rule 58 (exp -> TRUE .)
    MINUS           reduce using rule 58 (exp -> TRUE .)
    TIMES           reduce using rule 58 (exp -> TRUE .)
    DIVIDE          reduce using rule 58 (exp -> TRUE .)
    EQ              reduce using rule 58 (exp -> TRUE .)
    NOT_EQ          reduce using rule 58 (exp -> TRUE .)
    LT              reduce using rule 58 (exp -> TRUE .)
    GT              reduce using rule 58 (exp -> TRUE .)
    LE              reduce using rule 58 (exp -> TRUE .)
    GE              reduce using rule 58 (exp -> TRUE .)
    AND             reduce using rule 58 (exp -> TRUE .)
    NOT             reduce using rule 58 (exp -> TRUE .)
    $end            reduce using rule 58 (exp -> TRUE .)
    RPAREN          reduce using rule 58 (exp -> TRUE .)
    RBRACKET        reduce using rule 58 (exp -> TRUE .)
    COMMA           reduce using rule 58 (exp -> TRUE .)
    RBRACE          reduce using rule 58 (exp -> TRUE .)
    RETURN          reduce using rule 58 (exp -> TRUE .)
    LBRACE          reduce using rule 58 (exp -> TRUE .)
    IF              reduce using rule 58 (exp -> TRUE .)
    WHILE           reduce using rule 58 (exp -> TRUE .)
    THIS            reduce using rule 58 (exp -> TRUE .)
    IDENTIFIER      reduce using rule 58 (exp -> TRUE .)
    INT             reduce using rule 58 (exp -> TRUE .)
    BOOLEAN         reduce using rule 58 (exp -> TRUE .)
    VOID            reduce using rule 58 (exp -> TRUE .)
    FLOAT           reduce using rule 58 (exp -> TRUE .)
    LPAREN          reduce using rule 58 (exp -> TRUE .)
    TRUE            reduce using rule 58 (exp -> TRUE .)
    FALSE           reduce using rule 58 (exp -> TRUE .)
    NEW             reduce using rule 58 (exp -> TRUE .)
    NUMBER          reduce using rule 58 (exp -> TRUE .)
    ELSE            reduce using rule 58 (exp -> TRUE .)
    SEMICOLON       reduce using rule 58 (exp -> TRUE .)


state 12

    (64) exp -> NUMBER . Binop NUMBER
    (65) exp -> NUMBER . Binop float
    (70) float -> NUMBER . COMMA NUMBER
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    COMMA           shift and go to state 47
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 46

state 13

    (60) exp -> FALSE .

    PLUS            reduce using rule 60 (exp -> FALSE .)
    MINUS           reduce using rule 60 (exp -> FALSE .)
    TIMES           reduce using rule 60 (exp -> FALSE .)
    DIVIDE          reduce using rule 60 (exp -> FALSE .)
    EQ              reduce using rule 60 (exp -> FALSE .)
    NOT_EQ          reduce using rule 60 (exp -> FALSE .)
    LT              reduce using rule 60 (exp -> FALSE .)
    GT              reduce using rule 60 (exp -> FALSE .)
    LE              reduce using rule 60 (exp -> FALSE .)
    GE              reduce using rule 60 (exp -> FALSE .)
    AND             reduce using rule 60 (exp -> FALSE .)
    NOT             reduce using rule 60 (exp -> FALSE .)
    $end            reduce using rule 60 (exp -> FALSE .)
    RPAREN          reduce using rule 60 (exp -> FALSE .)
    RBRACKET        reduce using rule 60 (exp -> FALSE .)
    COMMA           reduce using rule 60 (exp -> FALSE .)
    RBRACE          reduce using rule 60 (exp -> FALSE .)
    RETURN          reduce using rule 60 (exp -> FALSE .)
    LBRACE          reduce using rule 60 (exp -> FALSE .)
    IF              reduce using rule 60 (exp -> FALSE .)
    WHILE           reduce using rule 60 (exp -> FALSE .)
    THIS            reduce using rule 60 (exp -> FALSE .)
    IDENTIFIER      reduce using rule 60 (exp -> FALSE .)
    INT             reduce using rule 60 (exp -> FALSE .)
    BOOLEAN         reduce using rule 60 (exp -> FALSE .)
    VOID            reduce using rule 60 (exp -> FALSE .)
    FLOAT           reduce using rule 60 (exp -> FALSE .)
    LPAREN          reduce using rule 60 (exp -> FALSE .)
    TRUE            reduce using rule 60 (exp -> FALSE .)
    FALSE           reduce using rule 60 (exp -> FALSE .)
    NEW             reduce using rule 60 (exp -> FALSE .)
    NUMBER          reduce using rule 60 (exp -> FALSE .)
    ELSE            reduce using rule 60 (exp -> FALSE .)
    SEMICOLON       reduce using rule 60 (exp -> FALSE .)


state 14

    (61) exp -> NEW . IDENTIFIER LPAREN RPAREN
    (62) exp -> NEW . INT LBRACKET exp RBRACKET
    (63) exp -> NEW . IDENTIFIER LBRACKET exp RBRACKET

    IDENTIFIER      shift and go to state 48
    INT             shift and go to state 49


state 15

    (23) PrimeType -> INT .
    (28) arraytype -> INT . LBRACKET RBRACKET

    IDENTIFIER      reduce using rule 23 (PrimeType -> INT .)
    LPAREN          reduce using rule 23 (PrimeType -> INT .)
    TRUE            reduce using rule 23 (PrimeType -> INT .)
    FALSE           reduce using rule 23 (PrimeType -> INT .)
    NEW             reduce using rule 23 (PrimeType -> INT .)
    NUMBER          reduce using rule 23 (PrimeType -> INT .)
    THIS            reduce using rule 23 (PrimeType -> INT .)
    NOT             reduce using rule 23 (PrimeType -> INT .)
    MINUS           reduce using rule 23 (PrimeType -> INT .)
    INT             reduce using rule 23 (PrimeType -> INT .)
    BOOLEAN         reduce using rule 23 (PrimeType -> INT .)
    VOID            reduce using rule 23 (PrimeType -> INT .)
    FLOAT           reduce using rule 23 (PrimeType -> INT .)
    PLUS            reduce using rule 23 (PrimeType -> INT .)
    TIMES           reduce using rule 23 (PrimeType -> INT .)
    DIVIDE          reduce using rule 23 (PrimeType -> INT .)
    EQ              reduce using rule 23 (PrimeType -> INT .)
    NOT_EQ          reduce using rule 23 (PrimeType -> INT .)
    LT              reduce using rule 23 (PrimeType -> INT .)
    GT              reduce using rule 23 (PrimeType -> INT .)
    LE              reduce using rule 23 (PrimeType -> INT .)
    GE              reduce using rule 23 (PrimeType -> INT .)
    AND             reduce using rule 23 (PrimeType -> INT .)
    $end            reduce using rule 23 (PrimeType -> INT .)
    RPAREN          reduce using rule 23 (PrimeType -> INT .)
    RBRACKET        reduce using rule 23 (PrimeType -> INT .)
    COMMA           reduce using rule 23 (PrimeType -> INT .)
    RBRACE          reduce using rule 23 (PrimeType -> INT .)
    RETURN          reduce using rule 23 (PrimeType -> INT .)
    LBRACE          reduce using rule 23 (PrimeType -> INT .)
    IF              reduce using rule 23 (PrimeType -> INT .)
    WHILE           reduce using rule 23 (PrimeType -> INT .)
    ELSE            reduce using rule 23 (PrimeType -> INT .)
    SEMICOLON       reduce using rule 23 (PrimeType -> INT .)
    LBRACKET        shift and go to state 50


state 16

    (66) exp -> float . Binop NUMBER
    (67) exp -> float . Binop float
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 51

state 17

    (20) Type -> PrimeType .

    IDENTIFIER      reduce using rule 20 (Type -> PrimeType .)
    LPAREN          reduce using rule 20 (Type -> PrimeType .)
    TRUE            reduce using rule 20 (Type -> PrimeType .)
    FALSE           reduce using rule 20 (Type -> PrimeType .)
    NEW             reduce using rule 20 (Type -> PrimeType .)
    NUMBER          reduce using rule 20 (Type -> PrimeType .)
    THIS            reduce using rule 20 (Type -> PrimeType .)
    NOT             reduce using rule 20 (Type -> PrimeType .)
    MINUS           reduce using rule 20 (Type -> PrimeType .)
    INT             reduce using rule 20 (Type -> PrimeType .)
    BOOLEAN         reduce using rule 20 (Type -> PrimeType .)
    VOID            reduce using rule 20 (Type -> PrimeType .)
    FLOAT           reduce using rule 20 (Type -> PrimeType .)
    PLUS            reduce using rule 20 (Type -> PrimeType .)
    TIMES           reduce using rule 20 (Type -> PrimeType .)
    DIVIDE          reduce using rule 20 (Type -> PrimeType .)
    EQ              reduce using rule 20 (Type -> PrimeType .)
    NOT_EQ          reduce using rule 20 (Type -> PrimeType .)
    LT              reduce using rule 20 (Type -> PrimeType .)
    GT              reduce using rule 20 (Type -> PrimeType .)
    LE              reduce using rule 20 (Type -> PrimeType .)
    GE              reduce using rule 20 (Type -> PrimeType .)
    AND             reduce using rule 20 (Type -> PrimeType .)
    $end            reduce using rule 20 (Type -> PrimeType .)
    RPAREN          reduce using rule 20 (Type -> PrimeType .)
    RBRACKET        reduce using rule 20 (Type -> PrimeType .)
    COMMA           reduce using rule 20 (Type -> PrimeType .)
    RBRACE          reduce using rule 20 (Type -> PrimeType .)
    RETURN          reduce using rule 20 (Type -> PrimeType .)
    LBRACE          reduce using rule 20 (Type -> PrimeType .)
    IF              reduce using rule 20 (Type -> PrimeType .)
    WHILE           reduce using rule 20 (Type -> PrimeType .)
    ELSE            reduce using rule 20 (Type -> PrimeType .)
    SEMICOLON       reduce using rule 20 (Type -> PrimeType .)


state 18

    (21) Type -> ClassType .
    (29) arraytype -> ClassType . LBRACKET RBRACKET

    IDENTIFIER      reduce using rule 21 (Type -> ClassType .)
    LPAREN          reduce using rule 21 (Type -> ClassType .)
    TRUE            reduce using rule 21 (Type -> ClassType .)
    FALSE           reduce using rule 21 (Type -> ClassType .)
    NEW             reduce using rule 21 (Type -> ClassType .)
    NUMBER          reduce using rule 21 (Type -> ClassType .)
    THIS            reduce using rule 21 (Type -> ClassType .)
    NOT             reduce using rule 21 (Type -> ClassType .)
    MINUS           reduce using rule 21 (Type -> ClassType .)
    INT             reduce using rule 21 (Type -> ClassType .)
    BOOLEAN         reduce using rule 21 (Type -> ClassType .)
    VOID            reduce using rule 21 (Type -> ClassType .)
    FLOAT           reduce using rule 21 (Type -> ClassType .)
    PLUS            reduce using rule 21 (Type -> ClassType .)
    TIMES           reduce using rule 21 (Type -> ClassType .)
    DIVIDE          reduce using rule 21 (Type -> ClassType .)
    EQ              reduce using rule 21 (Type -> ClassType .)
    NOT_EQ          reduce using rule 21 (Type -> ClassType .)
    LT              reduce using rule 21 (Type -> ClassType .)
    GT              reduce using rule 21 (Type -> ClassType .)
    LE              reduce using rule 21 (Type -> ClassType .)
    GE              reduce using rule 21 (Type -> ClassType .)
    AND             reduce using rule 21 (Type -> ClassType .)
    $end            reduce using rule 21 (Type -> ClassType .)
    RPAREN          reduce using rule 21 (Type -> ClassType .)
    RBRACKET        reduce using rule 21 (Type -> ClassType .)
    COMMA           reduce using rule 21 (Type -> ClassType .)
    RBRACE          reduce using rule 21 (Type -> ClassType .)
    RETURN          reduce using rule 21 (Type -> ClassType .)
    LBRACE          reduce using rule 21 (Type -> ClassType .)
    IF              reduce using rule 21 (Type -> ClassType .)
    WHILE           reduce using rule 21 (Type -> ClassType .)
    ELSE            reduce using rule 21 (Type -> ClassType .)
    SEMICOLON       reduce using rule 21 (Type -> ClassType .)
    LBRACKET        shift and go to state 52


state 19

    (22) Type -> arraytype .

    IDENTIFIER      reduce using rule 22 (Type -> arraytype .)
    LPAREN          reduce using rule 22 (Type -> arraytype .)
    TRUE            reduce using rule 22 (Type -> arraytype .)
    FALSE           reduce using rule 22 (Type -> arraytype .)
    NEW             reduce using rule 22 (Type -> arraytype .)
    NUMBER          reduce using rule 22 (Type -> arraytype .)
    THIS            reduce using rule 22 (Type -> arraytype .)
    NOT             reduce using rule 22 (Type -> arraytype .)
    MINUS           reduce using rule 22 (Type -> arraytype .)
    INT             reduce using rule 22 (Type -> arraytype .)
    BOOLEAN         reduce using rule 22 (Type -> arraytype .)
    VOID            reduce using rule 22 (Type -> arraytype .)
    FLOAT           reduce using rule 22 (Type -> arraytype .)
    PLUS            reduce using rule 22 (Type -> arraytype .)
    TIMES           reduce using rule 22 (Type -> arraytype .)
    DIVIDE          reduce using rule 22 (Type -> arraytype .)
    EQ              reduce using rule 22 (Type -> arraytype .)
    NOT_EQ          reduce using rule 22 (Type -> arraytype .)
    LT              reduce using rule 22 (Type -> arraytype .)
    GT              reduce using rule 22 (Type -> arraytype .)
    LE              reduce using rule 22 (Type -> arraytype .)
    GE              reduce using rule 22 (Type -> arraytype .)
    AND             reduce using rule 22 (Type -> arraytype .)
    $end            reduce using rule 22 (Type -> arraytype .)
    RPAREN          reduce using rule 22 (Type -> arraytype .)
    RBRACKET        reduce using rule 22 (Type -> arraytype .)
    COMMA           reduce using rule 22 (Type -> arraytype .)
    RBRACE          reduce using rule 22 (Type -> arraytype .)
    RETURN          reduce using rule 22 (Type -> arraytype .)
    LBRACE          reduce using rule 22 (Type -> arraytype .)
    IF              reduce using rule 22 (Type -> arraytype .)
    WHILE           reduce using rule 22 (Type -> arraytype .)
    ELSE            reduce using rule 22 (Type -> arraytype .)
    SEMICOLON       reduce using rule 22 (Type -> arraytype .)


state 20

    (32) Refrence -> THIS .

    LBRACKET        reduce using rule 32 (Refrence -> THIS .)
    LPAREN          reduce using rule 32 (Refrence -> THIS .)
    ASSIGN          reduce using rule 32 (Refrence -> THIS .)


state 21

    (68) Unop -> NOT .

    IDENTIFIER      reduce using rule 68 (Unop -> NOT .)
    LPAREN          reduce using rule 68 (Unop -> NOT .)
    TRUE            reduce using rule 68 (Unop -> NOT .)
    FALSE           reduce using rule 68 (Unop -> NOT .)
    NEW             reduce using rule 68 (Unop -> NOT .)
    NUMBER          reduce using rule 68 (Unop -> NOT .)
    THIS            reduce using rule 68 (Unop -> NOT .)
    NOT             reduce using rule 68 (Unop -> NOT .)
    MINUS           reduce using rule 68 (Unop -> NOT .)
    INT             reduce using rule 68 (Unop -> NOT .)
    BOOLEAN         reduce using rule 68 (Unop -> NOT .)
    VOID            reduce using rule 68 (Unop -> NOT .)
    FLOAT           reduce using rule 68 (Unop -> NOT .)
    PLUS            reduce using rule 68 (Unop -> NOT .)
    TIMES           reduce using rule 68 (Unop -> NOT .)
    DIVIDE          reduce using rule 68 (Unop -> NOT .)
    EQ              reduce using rule 68 (Unop -> NOT .)
    NOT_EQ          reduce using rule 68 (Unop -> NOT .)
    LT              reduce using rule 68 (Unop -> NOT .)
    GT              reduce using rule 68 (Unop -> NOT .)
    LE              reduce using rule 68 (Unop -> NOT .)
    GE              reduce using rule 68 (Unop -> NOT .)
    AND             reduce using rule 68 (Unop -> NOT .)
    $end            reduce using rule 68 (Unop -> NOT .)
    RPAREN          reduce using rule 68 (Unop -> NOT .)
    RBRACKET        reduce using rule 68 (Unop -> NOT .)
    COMMA           reduce using rule 68 (Unop -> NOT .)
    RBRACE          reduce using rule 68 (Unop -> NOT .)
    RETURN          reduce using rule 68 (Unop -> NOT .)
    LBRACE          reduce using rule 68 (Unop -> NOT .)
    IF              reduce using rule 68 (Unop -> NOT .)
    WHILE           reduce using rule 68 (Unop -> NOT .)
    ELSE            reduce using rule 68 (Unop -> NOT .)
    SEMICOLON       reduce using rule 68 (Unop -> NOT .)


state 22

    (69) Unop -> MINUS .

    IDENTIFIER      reduce using rule 69 (Unop -> MINUS .)
    LPAREN          reduce using rule 69 (Unop -> MINUS .)
    TRUE            reduce using rule 69 (Unop -> MINUS .)
    FALSE           reduce using rule 69 (Unop -> MINUS .)
    NEW             reduce using rule 69 (Unop -> MINUS .)
    NUMBER          reduce using rule 69 (Unop -> MINUS .)
    THIS            reduce using rule 69 (Unop -> MINUS .)
    NOT             reduce using rule 69 (Unop -> MINUS .)
    MINUS           reduce using rule 69 (Unop -> MINUS .)
    INT             reduce using rule 69 (Unop -> MINUS .)
    BOOLEAN         reduce using rule 69 (Unop -> MINUS .)
    VOID            reduce using rule 69 (Unop -> MINUS .)
    FLOAT           reduce using rule 69 (Unop -> MINUS .)
    PLUS            reduce using rule 69 (Unop -> MINUS .)
    TIMES           reduce using rule 69 (Unop -> MINUS .)
    DIVIDE          reduce using rule 69 (Unop -> MINUS .)
    EQ              reduce using rule 69 (Unop -> MINUS .)
    NOT_EQ          reduce using rule 69 (Unop -> MINUS .)
    LT              reduce using rule 69 (Unop -> MINUS .)
    GT              reduce using rule 69 (Unop -> MINUS .)
    LE              reduce using rule 69 (Unop -> MINUS .)
    GE              reduce using rule 69 (Unop -> MINUS .)
    AND             reduce using rule 69 (Unop -> MINUS .)
    $end            reduce using rule 69 (Unop -> MINUS .)
    RPAREN          reduce using rule 69 (Unop -> MINUS .)
    RBRACKET        reduce using rule 69 (Unop -> MINUS .)
    COMMA           reduce using rule 69 (Unop -> MINUS .)
    RBRACE          reduce using rule 69 (Unop -> MINUS .)
    RETURN          reduce using rule 69 (Unop -> MINUS .)
    LBRACE          reduce using rule 69 (Unop -> MINUS .)
    IF              reduce using rule 69 (Unop -> MINUS .)
    WHILE           reduce using rule 69 (Unop -> MINUS .)
    ELSE            reduce using rule 69 (Unop -> MINUS .)
    SEMICOLON       reduce using rule 69 (Unop -> MINUS .)


state 23

    (24) PrimeType -> BOOLEAN .

    IDENTIFIER      reduce using rule 24 (PrimeType -> BOOLEAN .)
    LPAREN          reduce using rule 24 (PrimeType -> BOOLEAN .)
    TRUE            reduce using rule 24 (PrimeType -> BOOLEAN .)
    FALSE           reduce using rule 24 (PrimeType -> BOOLEAN .)
    NEW             reduce using rule 24 (PrimeType -> BOOLEAN .)
    NUMBER          reduce using rule 24 (PrimeType -> BOOLEAN .)
    THIS            reduce using rule 24 (PrimeType -> BOOLEAN .)
    NOT             reduce using rule 24 (PrimeType -> BOOLEAN .)
    MINUS           reduce using rule 24 (PrimeType -> BOOLEAN .)
    INT             reduce using rule 24 (PrimeType -> BOOLEAN .)
    BOOLEAN         reduce using rule 24 (PrimeType -> BOOLEAN .)
    VOID            reduce using rule 24 (PrimeType -> BOOLEAN .)
    FLOAT           reduce using rule 24 (PrimeType -> BOOLEAN .)
    PLUS            reduce using rule 24 (PrimeType -> BOOLEAN .)
    TIMES           reduce using rule 24 (PrimeType -> BOOLEAN .)
    DIVIDE          reduce using rule 24 (PrimeType -> BOOLEAN .)
    EQ              reduce using rule 24 (PrimeType -> BOOLEAN .)
    NOT_EQ          reduce using rule 24 (PrimeType -> BOOLEAN .)
    LT              reduce using rule 24 (PrimeType -> BOOLEAN .)
    GT              reduce using rule 24 (PrimeType -> BOOLEAN .)
    LE              reduce using rule 24 (PrimeType -> BOOLEAN .)
    GE              reduce using rule 24 (PrimeType -> BOOLEAN .)
    AND             reduce using rule 24 (PrimeType -> BOOLEAN .)
    $end            reduce using rule 24 (PrimeType -> BOOLEAN .)
    RPAREN          reduce using rule 24 (PrimeType -> BOOLEAN .)
    RBRACKET        reduce using rule 24 (PrimeType -> BOOLEAN .)
    COMMA           reduce using rule 24 (PrimeType -> BOOLEAN .)
    RBRACE          reduce using rule 24 (PrimeType -> BOOLEAN .)
    RETURN          reduce using rule 24 (PrimeType -> BOOLEAN .)
    LBRACE          reduce using rule 24 (PrimeType -> BOOLEAN .)
    IF              reduce using rule 24 (PrimeType -> BOOLEAN .)
    WHILE           reduce using rule 24 (PrimeType -> BOOLEAN .)
    ELSE            reduce using rule 24 (PrimeType -> BOOLEAN .)
    SEMICOLON       reduce using rule 24 (PrimeType -> BOOLEAN .)


state 24

    (25) PrimeType -> VOID .

    IDENTIFIER      reduce using rule 25 (PrimeType -> VOID .)
    LPAREN          reduce using rule 25 (PrimeType -> VOID .)
    TRUE            reduce using rule 25 (PrimeType -> VOID .)
    FALSE           reduce using rule 25 (PrimeType -> VOID .)
    NEW             reduce using rule 25 (PrimeType -> VOID .)
    NUMBER          reduce using rule 25 (PrimeType -> VOID .)
    THIS            reduce using rule 25 (PrimeType -> VOID .)
    NOT             reduce using rule 25 (PrimeType -> VOID .)
    MINUS           reduce using rule 25 (PrimeType -> VOID .)
    INT             reduce using rule 25 (PrimeType -> VOID .)
    BOOLEAN         reduce using rule 25 (PrimeType -> VOID .)
    VOID            reduce using rule 25 (PrimeType -> VOID .)
    FLOAT           reduce using rule 25 (PrimeType -> VOID .)
    PLUS            reduce using rule 25 (PrimeType -> VOID .)
    TIMES           reduce using rule 25 (PrimeType -> VOID .)
    DIVIDE          reduce using rule 25 (PrimeType -> VOID .)
    EQ              reduce using rule 25 (PrimeType -> VOID .)
    NOT_EQ          reduce using rule 25 (PrimeType -> VOID .)
    LT              reduce using rule 25 (PrimeType -> VOID .)
    GT              reduce using rule 25 (PrimeType -> VOID .)
    LE              reduce using rule 25 (PrimeType -> VOID .)
    GE              reduce using rule 25 (PrimeType -> VOID .)
    AND             reduce using rule 25 (PrimeType -> VOID .)
    $end            reduce using rule 25 (PrimeType -> VOID .)
    RPAREN          reduce using rule 25 (PrimeType -> VOID .)
    RBRACKET        reduce using rule 25 (PrimeType -> VOID .)
    COMMA           reduce using rule 25 (PrimeType -> VOID .)
    RBRACE          reduce using rule 25 (PrimeType -> VOID .)
    RETURN          reduce using rule 25 (PrimeType -> VOID .)
    LBRACE          reduce using rule 25 (PrimeType -> VOID .)
    IF              reduce using rule 25 (PrimeType -> VOID .)
    WHILE           reduce using rule 25 (PrimeType -> VOID .)
    ELSE            reduce using rule 25 (PrimeType -> VOID .)
    SEMICOLON       reduce using rule 25 (PrimeType -> VOID .)


state 25

    (26) PrimeType -> FLOAT .

    IDENTIFIER      reduce using rule 26 (PrimeType -> FLOAT .)
    LPAREN          reduce using rule 26 (PrimeType -> FLOAT .)
    TRUE            reduce using rule 26 (PrimeType -> FLOAT .)
    FALSE           reduce using rule 26 (PrimeType -> FLOAT .)
    NEW             reduce using rule 26 (PrimeType -> FLOAT .)
    NUMBER          reduce using rule 26 (PrimeType -> FLOAT .)
    THIS            reduce using rule 26 (PrimeType -> FLOAT .)
    NOT             reduce using rule 26 (PrimeType -> FLOAT .)
    MINUS           reduce using rule 26 (PrimeType -> FLOAT .)
    INT             reduce using rule 26 (PrimeType -> FLOAT .)
    BOOLEAN         reduce using rule 26 (PrimeType -> FLOAT .)
    VOID            reduce using rule 26 (PrimeType -> FLOAT .)
    FLOAT           reduce using rule 26 (PrimeType -> FLOAT .)
    PLUS            reduce using rule 26 (PrimeType -> FLOAT .)
    TIMES           reduce using rule 26 (PrimeType -> FLOAT .)
    DIVIDE          reduce using rule 26 (PrimeType -> FLOAT .)
    EQ              reduce using rule 26 (PrimeType -> FLOAT .)
    NOT_EQ          reduce using rule 26 (PrimeType -> FLOAT .)
    LT              reduce using rule 26 (PrimeType -> FLOAT .)
    GT              reduce using rule 26 (PrimeType -> FLOAT .)
    LE              reduce using rule 26 (PrimeType -> FLOAT .)
    GE              reduce using rule 26 (PrimeType -> FLOAT .)
    AND             reduce using rule 26 (PrimeType -> FLOAT .)
    $end            reduce using rule 26 (PrimeType -> FLOAT .)
    RPAREN          reduce using rule 26 (PrimeType -> FLOAT .)
    RBRACKET        reduce using rule 26 (PrimeType -> FLOAT .)
    COMMA           reduce using rule 26 (PrimeType -> FLOAT .)
    RBRACE          reduce using rule 26 (PrimeType -> FLOAT .)
    RETURN          reduce using rule 26 (PrimeType -> FLOAT .)
    LBRACE          reduce using rule 26 (PrimeType -> FLOAT .)
    IF              reduce using rule 26 (PrimeType -> FLOAT .)
    WHILE           reduce using rule 26 (PrimeType -> FLOAT .)
    ELSE            reduce using rule 26 (PrimeType -> FLOAT .)
    SEMICOLON       reduce using rule 26 (PrimeType -> FLOAT .)


state 26

    (50) exp -> exp Binop . exp
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    $end            reduce using rule 49 (exp -> .)
    RPAREN          reduce using rule 49 (exp -> .)
    RBRACKET        reduce using rule 49 (exp -> .)
    COMMA           reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    LBRACE          reduce using rule 49 (exp -> .)
    IF              reduce using rule 49 (exp -> .)
    WHILE           reduce using rule 49 (exp -> .)
    ELSE            reduce using rule 49 (exp -> .)
    SEMICOLON       reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 53
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 27

    (71) Binop -> PLUS .

    IDENTIFIER      reduce using rule 71 (Binop -> PLUS .)
    LPAREN          reduce using rule 71 (Binop -> PLUS .)
    TRUE            reduce using rule 71 (Binop -> PLUS .)
    FALSE           reduce using rule 71 (Binop -> PLUS .)
    NEW             reduce using rule 71 (Binop -> PLUS .)
    NUMBER          reduce using rule 71 (Binop -> PLUS .)
    THIS            reduce using rule 71 (Binop -> PLUS .)
    NOT             reduce using rule 71 (Binop -> PLUS .)
    MINUS           reduce using rule 71 (Binop -> PLUS .)
    INT             reduce using rule 71 (Binop -> PLUS .)
    BOOLEAN         reduce using rule 71 (Binop -> PLUS .)
    VOID            reduce using rule 71 (Binop -> PLUS .)
    FLOAT           reduce using rule 71 (Binop -> PLUS .)
    PLUS            reduce using rule 71 (Binop -> PLUS .)
    TIMES           reduce using rule 71 (Binop -> PLUS .)
    DIVIDE          reduce using rule 71 (Binop -> PLUS .)
    EQ              reduce using rule 71 (Binop -> PLUS .)
    NOT_EQ          reduce using rule 71 (Binop -> PLUS .)
    LT              reduce using rule 71 (Binop -> PLUS .)
    GT              reduce using rule 71 (Binop -> PLUS .)
    LE              reduce using rule 71 (Binop -> PLUS .)
    GE              reduce using rule 71 (Binop -> PLUS .)
    AND             reduce using rule 71 (Binop -> PLUS .)
    $end            reduce using rule 71 (Binop -> PLUS .)
    RPAREN          reduce using rule 71 (Binop -> PLUS .)
    RBRACKET        reduce using rule 71 (Binop -> PLUS .)
    COMMA           reduce using rule 71 (Binop -> PLUS .)
    RBRACE          reduce using rule 71 (Binop -> PLUS .)
    RETURN          reduce using rule 71 (Binop -> PLUS .)
    LBRACE          reduce using rule 71 (Binop -> PLUS .)
    IF              reduce using rule 71 (Binop -> PLUS .)
    WHILE           reduce using rule 71 (Binop -> PLUS .)
    ELSE            reduce using rule 71 (Binop -> PLUS .)
    SEMICOLON       reduce using rule 71 (Binop -> PLUS .)


state 28

    (72) Binop -> MINUS .

    IDENTIFIER      reduce using rule 72 (Binop -> MINUS .)
    LPAREN          reduce using rule 72 (Binop -> MINUS .)
    TRUE            reduce using rule 72 (Binop -> MINUS .)
    FALSE           reduce using rule 72 (Binop -> MINUS .)
    NEW             reduce using rule 72 (Binop -> MINUS .)
    NUMBER          reduce using rule 72 (Binop -> MINUS .)
    THIS            reduce using rule 72 (Binop -> MINUS .)
    NOT             reduce using rule 72 (Binop -> MINUS .)
    MINUS           reduce using rule 72 (Binop -> MINUS .)
    INT             reduce using rule 72 (Binop -> MINUS .)
    BOOLEAN         reduce using rule 72 (Binop -> MINUS .)
    VOID            reduce using rule 72 (Binop -> MINUS .)
    FLOAT           reduce using rule 72 (Binop -> MINUS .)
    PLUS            reduce using rule 72 (Binop -> MINUS .)
    TIMES           reduce using rule 72 (Binop -> MINUS .)
    DIVIDE          reduce using rule 72 (Binop -> MINUS .)
    EQ              reduce using rule 72 (Binop -> MINUS .)
    NOT_EQ          reduce using rule 72 (Binop -> MINUS .)
    LT              reduce using rule 72 (Binop -> MINUS .)
    GT              reduce using rule 72 (Binop -> MINUS .)
    LE              reduce using rule 72 (Binop -> MINUS .)
    GE              reduce using rule 72 (Binop -> MINUS .)
    AND             reduce using rule 72 (Binop -> MINUS .)
    $end            reduce using rule 72 (Binop -> MINUS .)
    RPAREN          reduce using rule 72 (Binop -> MINUS .)
    RBRACKET        reduce using rule 72 (Binop -> MINUS .)
    COMMA           reduce using rule 72 (Binop -> MINUS .)
    RBRACE          reduce using rule 72 (Binop -> MINUS .)
    RETURN          reduce using rule 72 (Binop -> MINUS .)
    LBRACE          reduce using rule 72 (Binop -> MINUS .)
    IF              reduce using rule 72 (Binop -> MINUS .)
    WHILE           reduce using rule 72 (Binop -> MINUS .)
    ELSE            reduce using rule 72 (Binop -> MINUS .)
    SEMICOLON       reduce using rule 72 (Binop -> MINUS .)


state 29

    (73) Binop -> TIMES .

    IDENTIFIER      reduce using rule 73 (Binop -> TIMES .)
    LPAREN          reduce using rule 73 (Binop -> TIMES .)
    TRUE            reduce using rule 73 (Binop -> TIMES .)
    FALSE           reduce using rule 73 (Binop -> TIMES .)
    NEW             reduce using rule 73 (Binop -> TIMES .)
    NUMBER          reduce using rule 73 (Binop -> TIMES .)
    THIS            reduce using rule 73 (Binop -> TIMES .)
    NOT             reduce using rule 73 (Binop -> TIMES .)
    MINUS           reduce using rule 73 (Binop -> TIMES .)
    INT             reduce using rule 73 (Binop -> TIMES .)
    BOOLEAN         reduce using rule 73 (Binop -> TIMES .)
    VOID            reduce using rule 73 (Binop -> TIMES .)
    FLOAT           reduce using rule 73 (Binop -> TIMES .)
    PLUS            reduce using rule 73 (Binop -> TIMES .)
    TIMES           reduce using rule 73 (Binop -> TIMES .)
    DIVIDE          reduce using rule 73 (Binop -> TIMES .)
    EQ              reduce using rule 73 (Binop -> TIMES .)
    NOT_EQ          reduce using rule 73 (Binop -> TIMES .)
    LT              reduce using rule 73 (Binop -> TIMES .)
    GT              reduce using rule 73 (Binop -> TIMES .)
    LE              reduce using rule 73 (Binop -> TIMES .)
    GE              reduce using rule 73 (Binop -> TIMES .)
    AND             reduce using rule 73 (Binop -> TIMES .)
    $end            reduce using rule 73 (Binop -> TIMES .)
    RPAREN          reduce using rule 73 (Binop -> TIMES .)
    RBRACKET        reduce using rule 73 (Binop -> TIMES .)
    COMMA           reduce using rule 73 (Binop -> TIMES .)
    RBRACE          reduce using rule 73 (Binop -> TIMES .)
    RETURN          reduce using rule 73 (Binop -> TIMES .)
    LBRACE          reduce using rule 73 (Binop -> TIMES .)
    IF              reduce using rule 73 (Binop -> TIMES .)
    WHILE           reduce using rule 73 (Binop -> TIMES .)
    ELSE            reduce using rule 73 (Binop -> TIMES .)
    SEMICOLON       reduce using rule 73 (Binop -> TIMES .)


state 30

    (74) Binop -> DIVIDE .

    IDENTIFIER      reduce using rule 74 (Binop -> DIVIDE .)
    LPAREN          reduce using rule 74 (Binop -> DIVIDE .)
    TRUE            reduce using rule 74 (Binop -> DIVIDE .)
    FALSE           reduce using rule 74 (Binop -> DIVIDE .)
    NEW             reduce using rule 74 (Binop -> DIVIDE .)
    NUMBER          reduce using rule 74 (Binop -> DIVIDE .)
    THIS            reduce using rule 74 (Binop -> DIVIDE .)
    NOT             reduce using rule 74 (Binop -> DIVIDE .)
    MINUS           reduce using rule 74 (Binop -> DIVIDE .)
    INT             reduce using rule 74 (Binop -> DIVIDE .)
    BOOLEAN         reduce using rule 74 (Binop -> DIVIDE .)
    VOID            reduce using rule 74 (Binop -> DIVIDE .)
    FLOAT           reduce using rule 74 (Binop -> DIVIDE .)
    PLUS            reduce using rule 74 (Binop -> DIVIDE .)
    TIMES           reduce using rule 74 (Binop -> DIVIDE .)
    DIVIDE          reduce using rule 74 (Binop -> DIVIDE .)
    EQ              reduce using rule 74 (Binop -> DIVIDE .)
    NOT_EQ          reduce using rule 74 (Binop -> DIVIDE .)
    LT              reduce using rule 74 (Binop -> DIVIDE .)
    GT              reduce using rule 74 (Binop -> DIVIDE .)
    LE              reduce using rule 74 (Binop -> DIVIDE .)
    GE              reduce using rule 74 (Binop -> DIVIDE .)
    AND             reduce using rule 74 (Binop -> DIVIDE .)
    $end            reduce using rule 74 (Binop -> DIVIDE .)
    RPAREN          reduce using rule 74 (Binop -> DIVIDE .)
    RBRACKET        reduce using rule 74 (Binop -> DIVIDE .)
    COMMA           reduce using rule 74 (Binop -> DIVIDE .)
    RBRACE          reduce using rule 74 (Binop -> DIVIDE .)
    RETURN          reduce using rule 74 (Binop -> DIVIDE .)
    LBRACE          reduce using rule 74 (Binop -> DIVIDE .)
    IF              reduce using rule 74 (Binop -> DIVIDE .)
    WHILE           reduce using rule 74 (Binop -> DIVIDE .)
    ELSE            reduce using rule 74 (Binop -> DIVIDE .)
    SEMICOLON       reduce using rule 74 (Binop -> DIVIDE .)


state 31

    (75) Binop -> EQ .

    IDENTIFIER      reduce using rule 75 (Binop -> EQ .)
    LPAREN          reduce using rule 75 (Binop -> EQ .)
    TRUE            reduce using rule 75 (Binop -> EQ .)
    FALSE           reduce using rule 75 (Binop -> EQ .)
    NEW             reduce using rule 75 (Binop -> EQ .)
    NUMBER          reduce using rule 75 (Binop -> EQ .)
    THIS            reduce using rule 75 (Binop -> EQ .)
    NOT             reduce using rule 75 (Binop -> EQ .)
    MINUS           reduce using rule 75 (Binop -> EQ .)
    INT             reduce using rule 75 (Binop -> EQ .)
    BOOLEAN         reduce using rule 75 (Binop -> EQ .)
    VOID            reduce using rule 75 (Binop -> EQ .)
    FLOAT           reduce using rule 75 (Binop -> EQ .)
    PLUS            reduce using rule 75 (Binop -> EQ .)
    TIMES           reduce using rule 75 (Binop -> EQ .)
    DIVIDE          reduce using rule 75 (Binop -> EQ .)
    EQ              reduce using rule 75 (Binop -> EQ .)
    NOT_EQ          reduce using rule 75 (Binop -> EQ .)
    LT              reduce using rule 75 (Binop -> EQ .)
    GT              reduce using rule 75 (Binop -> EQ .)
    LE              reduce using rule 75 (Binop -> EQ .)
    GE              reduce using rule 75 (Binop -> EQ .)
    AND             reduce using rule 75 (Binop -> EQ .)
    $end            reduce using rule 75 (Binop -> EQ .)
    RPAREN          reduce using rule 75 (Binop -> EQ .)
    RBRACKET        reduce using rule 75 (Binop -> EQ .)
    COMMA           reduce using rule 75 (Binop -> EQ .)
    RBRACE          reduce using rule 75 (Binop -> EQ .)
    RETURN          reduce using rule 75 (Binop -> EQ .)
    LBRACE          reduce using rule 75 (Binop -> EQ .)
    IF              reduce using rule 75 (Binop -> EQ .)
    WHILE           reduce using rule 75 (Binop -> EQ .)
    ELSE            reduce using rule 75 (Binop -> EQ .)
    SEMICOLON       reduce using rule 75 (Binop -> EQ .)


state 32

    (76) Binop -> NOT_EQ .

    IDENTIFIER      reduce using rule 76 (Binop -> NOT_EQ .)
    LPAREN          reduce using rule 76 (Binop -> NOT_EQ .)
    TRUE            reduce using rule 76 (Binop -> NOT_EQ .)
    FALSE           reduce using rule 76 (Binop -> NOT_EQ .)
    NEW             reduce using rule 76 (Binop -> NOT_EQ .)
    NUMBER          reduce using rule 76 (Binop -> NOT_EQ .)
    THIS            reduce using rule 76 (Binop -> NOT_EQ .)
    NOT             reduce using rule 76 (Binop -> NOT_EQ .)
    MINUS           reduce using rule 76 (Binop -> NOT_EQ .)
    INT             reduce using rule 76 (Binop -> NOT_EQ .)
    BOOLEAN         reduce using rule 76 (Binop -> NOT_EQ .)
    VOID            reduce using rule 76 (Binop -> NOT_EQ .)
    FLOAT           reduce using rule 76 (Binop -> NOT_EQ .)
    PLUS            reduce using rule 76 (Binop -> NOT_EQ .)
    TIMES           reduce using rule 76 (Binop -> NOT_EQ .)
    DIVIDE          reduce using rule 76 (Binop -> NOT_EQ .)
    EQ              reduce using rule 76 (Binop -> NOT_EQ .)
    NOT_EQ          reduce using rule 76 (Binop -> NOT_EQ .)
    LT              reduce using rule 76 (Binop -> NOT_EQ .)
    GT              reduce using rule 76 (Binop -> NOT_EQ .)
    LE              reduce using rule 76 (Binop -> NOT_EQ .)
    GE              reduce using rule 76 (Binop -> NOT_EQ .)
    AND             reduce using rule 76 (Binop -> NOT_EQ .)
    $end            reduce using rule 76 (Binop -> NOT_EQ .)
    RPAREN          reduce using rule 76 (Binop -> NOT_EQ .)
    RBRACKET        reduce using rule 76 (Binop -> NOT_EQ .)
    COMMA           reduce using rule 76 (Binop -> NOT_EQ .)
    RBRACE          reduce using rule 76 (Binop -> NOT_EQ .)
    RETURN          reduce using rule 76 (Binop -> NOT_EQ .)
    LBRACE          reduce using rule 76 (Binop -> NOT_EQ .)
    IF              reduce using rule 76 (Binop -> NOT_EQ .)
    WHILE           reduce using rule 76 (Binop -> NOT_EQ .)
    ELSE            reduce using rule 76 (Binop -> NOT_EQ .)
    SEMICOLON       reduce using rule 76 (Binop -> NOT_EQ .)


state 33

    (77) Binop -> LT .

    IDENTIFIER      reduce using rule 77 (Binop -> LT .)
    LPAREN          reduce using rule 77 (Binop -> LT .)
    TRUE            reduce using rule 77 (Binop -> LT .)
    FALSE           reduce using rule 77 (Binop -> LT .)
    NEW             reduce using rule 77 (Binop -> LT .)
    NUMBER          reduce using rule 77 (Binop -> LT .)
    THIS            reduce using rule 77 (Binop -> LT .)
    NOT             reduce using rule 77 (Binop -> LT .)
    MINUS           reduce using rule 77 (Binop -> LT .)
    INT             reduce using rule 77 (Binop -> LT .)
    BOOLEAN         reduce using rule 77 (Binop -> LT .)
    VOID            reduce using rule 77 (Binop -> LT .)
    FLOAT           reduce using rule 77 (Binop -> LT .)
    PLUS            reduce using rule 77 (Binop -> LT .)
    TIMES           reduce using rule 77 (Binop -> LT .)
    DIVIDE          reduce using rule 77 (Binop -> LT .)
    EQ              reduce using rule 77 (Binop -> LT .)
    NOT_EQ          reduce using rule 77 (Binop -> LT .)
    LT              reduce using rule 77 (Binop -> LT .)
    GT              reduce using rule 77 (Binop -> LT .)
    LE              reduce using rule 77 (Binop -> LT .)
    GE              reduce using rule 77 (Binop -> LT .)
    AND             reduce using rule 77 (Binop -> LT .)
    $end            reduce using rule 77 (Binop -> LT .)
    RPAREN          reduce using rule 77 (Binop -> LT .)
    RBRACKET        reduce using rule 77 (Binop -> LT .)
    COMMA           reduce using rule 77 (Binop -> LT .)
    RBRACE          reduce using rule 77 (Binop -> LT .)
    RETURN          reduce using rule 77 (Binop -> LT .)
    LBRACE          reduce using rule 77 (Binop -> LT .)
    IF              reduce using rule 77 (Binop -> LT .)
    WHILE           reduce using rule 77 (Binop -> LT .)
    ELSE            reduce using rule 77 (Binop -> LT .)
    SEMICOLON       reduce using rule 77 (Binop -> LT .)


state 34

    (78) Binop -> GT .

    IDENTIFIER      reduce using rule 78 (Binop -> GT .)
    LPAREN          reduce using rule 78 (Binop -> GT .)
    TRUE            reduce using rule 78 (Binop -> GT .)
    FALSE           reduce using rule 78 (Binop -> GT .)
    NEW             reduce using rule 78 (Binop -> GT .)
    NUMBER          reduce using rule 78 (Binop -> GT .)
    THIS            reduce using rule 78 (Binop -> GT .)
    NOT             reduce using rule 78 (Binop -> GT .)
    MINUS           reduce using rule 78 (Binop -> GT .)
    INT             reduce using rule 78 (Binop -> GT .)
    BOOLEAN         reduce using rule 78 (Binop -> GT .)
    VOID            reduce using rule 78 (Binop -> GT .)
    FLOAT           reduce using rule 78 (Binop -> GT .)
    PLUS            reduce using rule 78 (Binop -> GT .)
    TIMES           reduce using rule 78 (Binop -> GT .)
    DIVIDE          reduce using rule 78 (Binop -> GT .)
    EQ              reduce using rule 78 (Binop -> GT .)
    NOT_EQ          reduce using rule 78 (Binop -> GT .)
    LT              reduce using rule 78 (Binop -> GT .)
    GT              reduce using rule 78 (Binop -> GT .)
    LE              reduce using rule 78 (Binop -> GT .)
    GE              reduce using rule 78 (Binop -> GT .)
    AND             reduce using rule 78 (Binop -> GT .)
    $end            reduce using rule 78 (Binop -> GT .)
    RPAREN          reduce using rule 78 (Binop -> GT .)
    RBRACKET        reduce using rule 78 (Binop -> GT .)
    COMMA           reduce using rule 78 (Binop -> GT .)
    RBRACE          reduce using rule 78 (Binop -> GT .)
    RETURN          reduce using rule 78 (Binop -> GT .)
    LBRACE          reduce using rule 78 (Binop -> GT .)
    IF              reduce using rule 78 (Binop -> GT .)
    WHILE           reduce using rule 78 (Binop -> GT .)
    ELSE            reduce using rule 78 (Binop -> GT .)
    SEMICOLON       reduce using rule 78 (Binop -> GT .)


state 35

    (79) Binop -> LE .

    IDENTIFIER      reduce using rule 79 (Binop -> LE .)
    LPAREN          reduce using rule 79 (Binop -> LE .)
    TRUE            reduce using rule 79 (Binop -> LE .)
    FALSE           reduce using rule 79 (Binop -> LE .)
    NEW             reduce using rule 79 (Binop -> LE .)
    NUMBER          reduce using rule 79 (Binop -> LE .)
    THIS            reduce using rule 79 (Binop -> LE .)
    NOT             reduce using rule 79 (Binop -> LE .)
    MINUS           reduce using rule 79 (Binop -> LE .)
    INT             reduce using rule 79 (Binop -> LE .)
    BOOLEAN         reduce using rule 79 (Binop -> LE .)
    VOID            reduce using rule 79 (Binop -> LE .)
    FLOAT           reduce using rule 79 (Binop -> LE .)
    PLUS            reduce using rule 79 (Binop -> LE .)
    TIMES           reduce using rule 79 (Binop -> LE .)
    DIVIDE          reduce using rule 79 (Binop -> LE .)
    EQ              reduce using rule 79 (Binop -> LE .)
    NOT_EQ          reduce using rule 79 (Binop -> LE .)
    LT              reduce using rule 79 (Binop -> LE .)
    GT              reduce using rule 79 (Binop -> LE .)
    LE              reduce using rule 79 (Binop -> LE .)
    GE              reduce using rule 79 (Binop -> LE .)
    AND             reduce using rule 79 (Binop -> LE .)
    $end            reduce using rule 79 (Binop -> LE .)
    RPAREN          reduce using rule 79 (Binop -> LE .)
    RBRACKET        reduce using rule 79 (Binop -> LE .)
    COMMA           reduce using rule 79 (Binop -> LE .)
    RBRACE          reduce using rule 79 (Binop -> LE .)
    RETURN          reduce using rule 79 (Binop -> LE .)
    LBRACE          reduce using rule 79 (Binop -> LE .)
    IF              reduce using rule 79 (Binop -> LE .)
    WHILE           reduce using rule 79 (Binop -> LE .)
    ELSE            reduce using rule 79 (Binop -> LE .)
    SEMICOLON       reduce using rule 79 (Binop -> LE .)


state 36

    (80) Binop -> GE .

    IDENTIFIER      reduce using rule 80 (Binop -> GE .)
    LPAREN          reduce using rule 80 (Binop -> GE .)
    TRUE            reduce using rule 80 (Binop -> GE .)
    FALSE           reduce using rule 80 (Binop -> GE .)
    NEW             reduce using rule 80 (Binop -> GE .)
    NUMBER          reduce using rule 80 (Binop -> GE .)
    THIS            reduce using rule 80 (Binop -> GE .)
    NOT             reduce using rule 80 (Binop -> GE .)
    MINUS           reduce using rule 80 (Binop -> GE .)
    INT             reduce using rule 80 (Binop -> GE .)
    BOOLEAN         reduce using rule 80 (Binop -> GE .)
    VOID            reduce using rule 80 (Binop -> GE .)
    FLOAT           reduce using rule 80 (Binop -> GE .)
    PLUS            reduce using rule 80 (Binop -> GE .)
    TIMES           reduce using rule 80 (Binop -> GE .)
    DIVIDE          reduce using rule 80 (Binop -> GE .)
    EQ              reduce using rule 80 (Binop -> GE .)
    NOT_EQ          reduce using rule 80 (Binop -> GE .)
    LT              reduce using rule 80 (Binop -> GE .)
    GT              reduce using rule 80 (Binop -> GE .)
    LE              reduce using rule 80 (Binop -> GE .)
    GE              reduce using rule 80 (Binop -> GE .)
    AND             reduce using rule 80 (Binop -> GE .)
    $end            reduce using rule 80 (Binop -> GE .)
    RPAREN          reduce using rule 80 (Binop -> GE .)
    RBRACKET        reduce using rule 80 (Binop -> GE .)
    COMMA           reduce using rule 80 (Binop -> GE .)
    RBRACE          reduce using rule 80 (Binop -> GE .)
    RETURN          reduce using rule 80 (Binop -> GE .)
    LBRACE          reduce using rule 80 (Binop -> GE .)
    IF              reduce using rule 80 (Binop -> GE .)
    WHILE           reduce using rule 80 (Binop -> GE .)
    ELSE            reduce using rule 80 (Binop -> GE .)
    SEMICOLON       reduce using rule 80 (Binop -> GE .)


state 37

    (81) Binop -> AND .

    IDENTIFIER      reduce using rule 81 (Binop -> AND .)
    LPAREN          reduce using rule 81 (Binop -> AND .)
    TRUE            reduce using rule 81 (Binop -> AND .)
    FALSE           reduce using rule 81 (Binop -> AND .)
    NEW             reduce using rule 81 (Binop -> AND .)
    NUMBER          reduce using rule 81 (Binop -> AND .)
    THIS            reduce using rule 81 (Binop -> AND .)
    NOT             reduce using rule 81 (Binop -> AND .)
    MINUS           reduce using rule 81 (Binop -> AND .)
    INT             reduce using rule 81 (Binop -> AND .)
    BOOLEAN         reduce using rule 81 (Binop -> AND .)
    VOID            reduce using rule 81 (Binop -> AND .)
    FLOAT           reduce using rule 81 (Binop -> AND .)
    PLUS            reduce using rule 81 (Binop -> AND .)
    TIMES           reduce using rule 81 (Binop -> AND .)
    DIVIDE          reduce using rule 81 (Binop -> AND .)
    EQ              reduce using rule 81 (Binop -> AND .)
    NOT_EQ          reduce using rule 81 (Binop -> AND .)
    LT              reduce using rule 81 (Binop -> AND .)
    GT              reduce using rule 81 (Binop -> AND .)
    LE              reduce using rule 81 (Binop -> AND .)
    GE              reduce using rule 81 (Binop -> AND .)
    AND             reduce using rule 81 (Binop -> AND .)
    $end            reduce using rule 81 (Binop -> AND .)
    RPAREN          reduce using rule 81 (Binop -> AND .)
    RBRACKET        reduce using rule 81 (Binop -> AND .)
    COMMA           reduce using rule 81 (Binop -> AND .)
    RBRACE          reduce using rule 81 (Binop -> AND .)
    RETURN          reduce using rule 81 (Binop -> AND .)
    LBRACE          reduce using rule 81 (Binop -> AND .)
    IF              reduce using rule 81 (Binop -> AND .)
    WHILE           reduce using rule 81 (Binop -> AND .)
    ELSE            reduce using rule 81 (Binop -> AND .)
    SEMICOLON       reduce using rule 81 (Binop -> AND .)


state 38

    (82) Binop -> NOT .

    IDENTIFIER      reduce using rule 82 (Binop -> NOT .)
    LPAREN          reduce using rule 82 (Binop -> NOT .)
    TRUE            reduce using rule 82 (Binop -> NOT .)
    FALSE           reduce using rule 82 (Binop -> NOT .)
    NEW             reduce using rule 82 (Binop -> NOT .)
    NUMBER          reduce using rule 82 (Binop -> NOT .)
    THIS            reduce using rule 82 (Binop -> NOT .)
    NOT             reduce using rule 82 (Binop -> NOT .)
    MINUS           reduce using rule 82 (Binop -> NOT .)
    INT             reduce using rule 82 (Binop -> NOT .)
    BOOLEAN         reduce using rule 82 (Binop -> NOT .)
    VOID            reduce using rule 82 (Binop -> NOT .)
    FLOAT           reduce using rule 82 (Binop -> NOT .)
    PLUS            reduce using rule 82 (Binop -> NOT .)
    TIMES           reduce using rule 82 (Binop -> NOT .)
    DIVIDE          reduce using rule 82 (Binop -> NOT .)
    EQ              reduce using rule 82 (Binop -> NOT .)
    NOT_EQ          reduce using rule 82 (Binop -> NOT .)
    LT              reduce using rule 82 (Binop -> NOT .)
    GT              reduce using rule 82 (Binop -> NOT .)
    LE              reduce using rule 82 (Binop -> NOT .)
    GE              reduce using rule 82 (Binop -> NOT .)
    AND             reduce using rule 82 (Binop -> NOT .)
    $end            reduce using rule 82 (Binop -> NOT .)
    RPAREN          reduce using rule 82 (Binop -> NOT .)
    RBRACKET        reduce using rule 82 (Binop -> NOT .)
    COMMA           reduce using rule 82 (Binop -> NOT .)
    RBRACE          reduce using rule 82 (Binop -> NOT .)
    RETURN          reduce using rule 82 (Binop -> NOT .)
    LBRACE          reduce using rule 82 (Binop -> NOT .)
    IF              reduce using rule 82 (Binop -> NOT .)
    WHILE           reduce using rule 82 (Binop -> NOT .)
    ELSE            reduce using rule 82 (Binop -> NOT .)
    SEMICOLON       reduce using rule 82 (Binop -> NOT .)


state 39

    (4) ClassDeclaration -> CLASS IDENTIFIER . LBRACE RBRACE
    (5) ClassDeclaration -> CLASS IDENTIFIER . LBRACE MethodDeclaration RBRACE
    (6) ClassDeclaration -> CLASS IDENTIFIER . LBRACE FieldDeclaration RBRACE

    LBRACE          shift and go to state 54


state 40

    (59) exp -> IDENTIFIER Binop . NUMBER

    NUMBER          shift and go to state 55


state 41

    (52) exp -> Type exp .
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 52 (exp -> Type exp .)
    RPAREN          reduce using rule 52 (exp -> Type exp .)
    RBRACKET        reduce using rule 52 (exp -> Type exp .)
    COMMA           reduce using rule 52 (exp -> Type exp .)
    RBRACE          reduce using rule 52 (exp -> Type exp .)
    RETURN          reduce using rule 52 (exp -> Type exp .)
    LBRACE          reduce using rule 52 (exp -> Type exp .)
    IF              reduce using rule 52 (exp -> Type exp .)
    WHILE           reduce using rule 52 (exp -> Type exp .)
    THIS            reduce using rule 52 (exp -> Type exp .)
    IDENTIFIER      reduce using rule 52 (exp -> Type exp .)
    INT             reduce using rule 52 (exp -> Type exp .)
    BOOLEAN         reduce using rule 52 (exp -> Type exp .)
    VOID            reduce using rule 52 (exp -> Type exp .)
    FLOAT           reduce using rule 52 (exp -> Type exp .)
    LPAREN          reduce using rule 52 (exp -> Type exp .)
    TRUE            reduce using rule 52 (exp -> Type exp .)
    FALSE           reduce using rule 52 (exp -> Type exp .)
    NEW             reduce using rule 52 (exp -> Type exp .)
    NUMBER          reduce using rule 52 (exp -> Type exp .)
    ELSE            reduce using rule 52 (exp -> Type exp .)
    SEMICOLON       reduce using rule 52 (exp -> Type exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

  ! PLUS            [ reduce using rule 52 (exp -> Type exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> Type exp .) ]
  ! TIMES           [ reduce using rule 52 (exp -> Type exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> Type exp .) ]
  ! EQ              [ reduce using rule 52 (exp -> Type exp .) ]
  ! NOT_EQ          [ reduce using rule 52 (exp -> Type exp .) ]
  ! LT              [ reduce using rule 52 (exp -> Type exp .) ]
  ! GT              [ reduce using rule 52 (exp -> Type exp .) ]
  ! LE              [ reduce using rule 52 (exp -> Type exp .) ]
  ! GE              [ reduce using rule 52 (exp -> Type exp .) ]
  ! AND             [ reduce using rule 52 (exp -> Type exp .) ]
  ! NOT             [ reduce using rule 52 (exp -> Type exp .) ]

    Binop                          shift and go to state 26

state 42

    (53) exp -> Refrence LBRACKET . exp RBRACKET
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    Refrence                       shift and go to state 8
    exp                            shift and go to state 56
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 43

    (54) exp -> Refrence LPAREN . RPAREN
    (55) exp -> Refrence LPAREN . argumentlist RPAREN
    (30) argumentlist -> . exp
    (31) argumentlist -> . exp COMMA exp
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RPAREN          shift and go to state 57
    COMMA           reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! RPAREN          [ reduce using rule 49 (exp -> .) ]

    Refrence                       shift and go to state 8
    argumentlist                   shift and go to state 58
    exp                            shift and go to state 59
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 44

    (57) exp -> LPAREN exp . RPAREN
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RPAREN          shift and go to state 60
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 45

    (56) exp -> Unop exp .
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 56 (exp -> Unop exp .)
    RPAREN          reduce using rule 56 (exp -> Unop exp .)
    RBRACKET        reduce using rule 56 (exp -> Unop exp .)
    COMMA           reduce using rule 56 (exp -> Unop exp .)
    RBRACE          reduce using rule 56 (exp -> Unop exp .)
    RETURN          reduce using rule 56 (exp -> Unop exp .)
    LBRACE          reduce using rule 56 (exp -> Unop exp .)
    IF              reduce using rule 56 (exp -> Unop exp .)
    WHILE           reduce using rule 56 (exp -> Unop exp .)
    THIS            reduce using rule 56 (exp -> Unop exp .)
    IDENTIFIER      reduce using rule 56 (exp -> Unop exp .)
    INT             reduce using rule 56 (exp -> Unop exp .)
    BOOLEAN         reduce using rule 56 (exp -> Unop exp .)
    VOID            reduce using rule 56 (exp -> Unop exp .)
    FLOAT           reduce using rule 56 (exp -> Unop exp .)
    LPAREN          reduce using rule 56 (exp -> Unop exp .)
    TRUE            reduce using rule 56 (exp -> Unop exp .)
    FALSE           reduce using rule 56 (exp -> Unop exp .)
    NEW             reduce using rule 56 (exp -> Unop exp .)
    NUMBER          reduce using rule 56 (exp -> Unop exp .)
    ELSE            reduce using rule 56 (exp -> Unop exp .)
    SEMICOLON       reduce using rule 56 (exp -> Unop exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

  ! PLUS            [ reduce using rule 56 (exp -> Unop exp .) ]
  ! MINUS           [ reduce using rule 56 (exp -> Unop exp .) ]
  ! TIMES           [ reduce using rule 56 (exp -> Unop exp .) ]
  ! DIVIDE          [ reduce using rule 56 (exp -> Unop exp .) ]
  ! EQ              [ reduce using rule 56 (exp -> Unop exp .) ]
  ! NOT_EQ          [ reduce using rule 56 (exp -> Unop exp .) ]
  ! LT              [ reduce using rule 56 (exp -> Unop exp .) ]
  ! GT              [ reduce using rule 56 (exp -> Unop exp .) ]
  ! LE              [ reduce using rule 56 (exp -> Unop exp .) ]
  ! GE              [ reduce using rule 56 (exp -> Unop exp .) ]
  ! AND             [ reduce using rule 56 (exp -> Unop exp .) ]
  ! NOT             [ reduce using rule 56 (exp -> Unop exp .) ]

    Binop                          shift and go to state 26

state 46

    (64) exp -> NUMBER Binop . NUMBER
    (65) exp -> NUMBER Binop . float
    (70) float -> . NUMBER COMMA NUMBER

    NUMBER          shift and go to state 61

    float                          shift and go to state 62

state 47

    (70) float -> NUMBER COMMA . NUMBER

    NUMBER          shift and go to state 63


state 48

    (61) exp -> NEW IDENTIFIER . LPAREN RPAREN
    (63) exp -> NEW IDENTIFIER . LBRACKET exp RBRACKET

    LPAREN          shift and go to state 64
    LBRACKET        shift and go to state 65


state 49

    (62) exp -> NEW INT . LBRACKET exp RBRACKET

    LBRACKET        shift and go to state 66


state 50

    (28) arraytype -> INT LBRACKET . RBRACKET

    RBRACKET        shift and go to state 67


state 51

    (66) exp -> float Binop . NUMBER
    (67) exp -> float Binop . float
    (70) float -> . NUMBER COMMA NUMBER

    NUMBER          shift and go to state 69

    float                          shift and go to state 68

state 52

    (29) arraytype -> ClassType LBRACKET . RBRACKET

    RBRACKET        shift and go to state 70


state 53

    (50) exp -> exp Binop exp .
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 50 (exp -> exp Binop exp .)
    RPAREN          reduce using rule 50 (exp -> exp Binop exp .)
    RBRACKET        reduce using rule 50 (exp -> exp Binop exp .)
    COMMA           reduce using rule 50 (exp -> exp Binop exp .)
    RBRACE          reduce using rule 50 (exp -> exp Binop exp .)
    RETURN          reduce using rule 50 (exp -> exp Binop exp .)
    LBRACE          reduce using rule 50 (exp -> exp Binop exp .)
    IF              reduce using rule 50 (exp -> exp Binop exp .)
    WHILE           reduce using rule 50 (exp -> exp Binop exp .)
    THIS            reduce using rule 50 (exp -> exp Binop exp .)
    IDENTIFIER      reduce using rule 50 (exp -> exp Binop exp .)
    INT             reduce using rule 50 (exp -> exp Binop exp .)
    BOOLEAN         reduce using rule 50 (exp -> exp Binop exp .)
    VOID            reduce using rule 50 (exp -> exp Binop exp .)
    FLOAT           reduce using rule 50 (exp -> exp Binop exp .)
    LPAREN          reduce using rule 50 (exp -> exp Binop exp .)
    TRUE            reduce using rule 50 (exp -> exp Binop exp .)
    FALSE           reduce using rule 50 (exp -> exp Binop exp .)
    NEW             reduce using rule 50 (exp -> exp Binop exp .)
    NUMBER          reduce using rule 50 (exp -> exp Binop exp .)
    ELSE            reduce using rule 50 (exp -> exp Binop exp .)
    SEMICOLON       reduce using rule 50 (exp -> exp Binop exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

  ! PLUS            [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! MINUS           [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! TIMES           [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! DIVIDE          [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! EQ              [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! NOT_EQ          [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! LT              [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! GT              [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! LE              [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! GE              [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! AND             [ reduce using rule 50 (exp -> exp Binop exp .) ]
  ! NOT             [ reduce using rule 50 (exp -> exp Binop exp .) ]

    Binop                          shift and go to state 26

state 54

    (4) ClassDeclaration -> CLASS IDENTIFIER LBRACE . RBRACE
    (5) ClassDeclaration -> CLASS IDENTIFIER LBRACE . MethodDeclaration RBRACE
    (6) ClassDeclaration -> CLASS IDENTIFIER LBRACE . FieldDeclaration RBRACE
    (8) MethodDeclaration -> . Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE
    (9) MethodDeclaration -> . Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (10) MethodDeclaration -> . Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> . Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE
    (7) FieldDeclaration -> . Declarators IDENTIFIER SEMICOLON
    (14) Declarators -> . Type
    (15) Declarators -> . STATIC Type
    (16) Declarators -> . PUBLIC Type
    (17) Declarators -> . PRIVATE Type
    (18) Declarators -> . PUBLIC STATIC Type
    (19) Declarators -> . PRIVATE STATIC Type
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    RBRACE          shift and go to state 72
    STATIC          shift and go to state 77
    PUBLIC          shift and go to state 78
    PRIVATE         shift and go to state 79
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    MethodDeclaration              shift and go to state 73
    FieldDeclaration               shift and go to state 74
    Declarators                    shift and go to state 75
    Type                           shift and go to state 76
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 55

    (59) exp -> IDENTIFIER Binop NUMBER .

    PLUS            reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    MINUS           reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    TIMES           reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    DIVIDE          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    EQ              reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    NOT_EQ          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    LT              reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    GT              reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    LE              reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    GE              reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    AND             reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    NOT             reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    $end            reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    RPAREN          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    RBRACKET        reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    COMMA           reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    RBRACE          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    RETURN          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    LBRACE          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    IF              reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    WHILE           reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    THIS            reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    IDENTIFIER      reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    INT             reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    BOOLEAN         reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    VOID            reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    FLOAT           reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    LPAREN          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    TRUE            reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    FALSE           reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    NEW             reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    NUMBER          reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    ELSE            reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)
    SEMICOLON       reduce using rule 59 (exp -> IDENTIFIER Binop NUMBER .)


state 56

    (53) exp -> Refrence LBRACKET exp . RBRACKET
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RBRACKET        shift and go to state 80
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 57

    (54) exp -> Refrence LPAREN RPAREN .

    PLUS            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    MINUS           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    TIMES           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    DIVIDE          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    EQ              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NOT_EQ          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LT              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    GT              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LE              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    GE              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    AND             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NOT             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    $end            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    RPAREN          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    RBRACKET        reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    COMMA           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    RBRACE          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    RETURN          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LBRACE          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    IF              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    WHILE           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    THIS            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    INT             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    BOOLEAN         reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    VOID            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    FLOAT           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LPAREN          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    TRUE            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    FALSE           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NEW             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NUMBER          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    ELSE            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    SEMICOLON       reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)


state 58

    (55) exp -> Refrence LPAREN argumentlist . RPAREN

    RPAREN          shift and go to state 81


state 59

    (30) argumentlist -> exp .
    (31) argumentlist -> exp . COMMA exp
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RPAREN          reduce using rule 30 (argumentlist -> exp .)
    COMMA           shift and go to state 82
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 60

    (57) exp -> LPAREN exp RPAREN .

    PLUS            reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    EQ              reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    NOT_EQ          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    NOT             reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    $end            reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    RBRACE          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    RETURN          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    LBRACE          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    IF              reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    WHILE           reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    THIS            reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    IDENTIFIER      reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    INT             reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    BOOLEAN         reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    VOID            reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    FLOAT           reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    TRUE            reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    FALSE           reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    NEW             reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    NUMBER          reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    ELSE            reduce using rule 57 (exp -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 57 (exp -> LPAREN exp RPAREN .)


state 61

    (64) exp -> NUMBER Binop NUMBER .
    (70) float -> NUMBER . COMMA NUMBER

  ! shift/reduce conflict for COMMA resolved as shift
    PLUS            reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    MINUS           reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    TIMES           reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    DIVIDE          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    EQ              reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    NOT_EQ          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    LT              reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    GT              reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    LE              reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    GE              reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    AND             reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    NOT             reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    $end            reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    RPAREN          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    RBRACKET        reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    RBRACE          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    RETURN          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    LBRACE          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    IF              reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    WHILE           reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    THIS            reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    IDENTIFIER      reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    INT             reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    BOOLEAN         reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    VOID            reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    FLOAT           reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    LPAREN          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    TRUE            reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    FALSE           reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    NEW             reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    NUMBER          reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    ELSE            reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    SEMICOLON       reduce using rule 64 (exp -> NUMBER Binop NUMBER .)
    COMMA           shift and go to state 47

  ! COMMA           [ reduce using rule 64 (exp -> NUMBER Binop NUMBER .) ]


state 62

    (65) exp -> NUMBER Binop float .

    PLUS            reduce using rule 65 (exp -> NUMBER Binop float .)
    MINUS           reduce using rule 65 (exp -> NUMBER Binop float .)
    TIMES           reduce using rule 65 (exp -> NUMBER Binop float .)
    DIVIDE          reduce using rule 65 (exp -> NUMBER Binop float .)
    EQ              reduce using rule 65 (exp -> NUMBER Binop float .)
    NOT_EQ          reduce using rule 65 (exp -> NUMBER Binop float .)
    LT              reduce using rule 65 (exp -> NUMBER Binop float .)
    GT              reduce using rule 65 (exp -> NUMBER Binop float .)
    LE              reduce using rule 65 (exp -> NUMBER Binop float .)
    GE              reduce using rule 65 (exp -> NUMBER Binop float .)
    AND             reduce using rule 65 (exp -> NUMBER Binop float .)
    NOT             reduce using rule 65 (exp -> NUMBER Binop float .)
    $end            reduce using rule 65 (exp -> NUMBER Binop float .)
    RPAREN          reduce using rule 65 (exp -> NUMBER Binop float .)
    RBRACKET        reduce using rule 65 (exp -> NUMBER Binop float .)
    COMMA           reduce using rule 65 (exp -> NUMBER Binop float .)
    RBRACE          reduce using rule 65 (exp -> NUMBER Binop float .)
    RETURN          reduce using rule 65 (exp -> NUMBER Binop float .)
    LBRACE          reduce using rule 65 (exp -> NUMBER Binop float .)
    IF              reduce using rule 65 (exp -> NUMBER Binop float .)
    WHILE           reduce using rule 65 (exp -> NUMBER Binop float .)
    THIS            reduce using rule 65 (exp -> NUMBER Binop float .)
    IDENTIFIER      reduce using rule 65 (exp -> NUMBER Binop float .)
    INT             reduce using rule 65 (exp -> NUMBER Binop float .)
    BOOLEAN         reduce using rule 65 (exp -> NUMBER Binop float .)
    VOID            reduce using rule 65 (exp -> NUMBER Binop float .)
    FLOAT           reduce using rule 65 (exp -> NUMBER Binop float .)
    LPAREN          reduce using rule 65 (exp -> NUMBER Binop float .)
    TRUE            reduce using rule 65 (exp -> NUMBER Binop float .)
    FALSE           reduce using rule 65 (exp -> NUMBER Binop float .)
    NEW             reduce using rule 65 (exp -> NUMBER Binop float .)
    NUMBER          reduce using rule 65 (exp -> NUMBER Binop float .)
    ELSE            reduce using rule 65 (exp -> NUMBER Binop float .)
    SEMICOLON       reduce using rule 65 (exp -> NUMBER Binop float .)


state 63

    (70) float -> NUMBER COMMA NUMBER .

    PLUS            reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    MINUS           reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    TIMES           reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    DIVIDE          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    EQ              reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    NOT_EQ          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    LT              reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    GT              reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    LE              reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    GE              reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    AND             reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    NOT             reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    $end            reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    RPAREN          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    RBRACKET        reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    COMMA           reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    RBRACE          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    RETURN          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    LBRACE          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    IF              reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    WHILE           reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    THIS            reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    IDENTIFIER      reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    INT             reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    BOOLEAN         reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    VOID            reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    FLOAT           reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    LPAREN          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    TRUE            reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    FALSE           reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    NEW             reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    NUMBER          reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    ELSE            reduce using rule 70 (float -> NUMBER COMMA NUMBER .)
    SEMICOLON       reduce using rule 70 (float -> NUMBER COMMA NUMBER .)


state 64

    (61) exp -> NEW IDENTIFIER LPAREN . RPAREN

    RPAREN          shift and go to state 83


state 65

    (63) exp -> NEW IDENTIFIER LBRACKET . exp RBRACKET
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 84
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 66

    (62) exp -> NEW INT LBRACKET . exp RBRACKET
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 85
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 67

    (28) arraytype -> INT LBRACKET RBRACKET .

    IDENTIFIER      reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    LPAREN          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    TRUE            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    FALSE           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    NEW             reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    NUMBER          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    THIS            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    NOT             reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    MINUS           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    INT             reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    BOOLEAN         reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    VOID            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    FLOAT           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    PLUS            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    TIMES           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    EQ              reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    NOT_EQ          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    LT              reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    GT              reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    LE              reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    GE              reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    AND             reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    $end            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    RPAREN          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    COMMA           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    RBRACE          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    RETURN          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    LBRACE          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    IF              reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    WHILE           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    ELSE            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)


state 68

    (67) exp -> float Binop float .

    PLUS            reduce using rule 67 (exp -> float Binop float .)
    MINUS           reduce using rule 67 (exp -> float Binop float .)
    TIMES           reduce using rule 67 (exp -> float Binop float .)
    DIVIDE          reduce using rule 67 (exp -> float Binop float .)
    EQ              reduce using rule 67 (exp -> float Binop float .)
    NOT_EQ          reduce using rule 67 (exp -> float Binop float .)
    LT              reduce using rule 67 (exp -> float Binop float .)
    GT              reduce using rule 67 (exp -> float Binop float .)
    LE              reduce using rule 67 (exp -> float Binop float .)
    GE              reduce using rule 67 (exp -> float Binop float .)
    AND             reduce using rule 67 (exp -> float Binop float .)
    NOT             reduce using rule 67 (exp -> float Binop float .)
    $end            reduce using rule 67 (exp -> float Binop float .)
    RPAREN          reduce using rule 67 (exp -> float Binop float .)
    RBRACKET        reduce using rule 67 (exp -> float Binop float .)
    COMMA           reduce using rule 67 (exp -> float Binop float .)
    RBRACE          reduce using rule 67 (exp -> float Binop float .)
    RETURN          reduce using rule 67 (exp -> float Binop float .)
    LBRACE          reduce using rule 67 (exp -> float Binop float .)
    IF              reduce using rule 67 (exp -> float Binop float .)
    WHILE           reduce using rule 67 (exp -> float Binop float .)
    THIS            reduce using rule 67 (exp -> float Binop float .)
    IDENTIFIER      reduce using rule 67 (exp -> float Binop float .)
    INT             reduce using rule 67 (exp -> float Binop float .)
    BOOLEAN         reduce using rule 67 (exp -> float Binop float .)
    VOID            reduce using rule 67 (exp -> float Binop float .)
    FLOAT           reduce using rule 67 (exp -> float Binop float .)
    LPAREN          reduce using rule 67 (exp -> float Binop float .)
    TRUE            reduce using rule 67 (exp -> float Binop float .)
    FALSE           reduce using rule 67 (exp -> float Binop float .)
    NEW             reduce using rule 67 (exp -> float Binop float .)
    NUMBER          reduce using rule 67 (exp -> float Binop float .)
    ELSE            reduce using rule 67 (exp -> float Binop float .)
    SEMICOLON       reduce using rule 67 (exp -> float Binop float .)


state 69

    (66) exp -> float Binop NUMBER .
    (70) float -> NUMBER . COMMA NUMBER

  ! shift/reduce conflict for COMMA resolved as shift
    PLUS            reduce using rule 66 (exp -> float Binop NUMBER .)
    MINUS           reduce using rule 66 (exp -> float Binop NUMBER .)
    TIMES           reduce using rule 66 (exp -> float Binop NUMBER .)
    DIVIDE          reduce using rule 66 (exp -> float Binop NUMBER .)
    EQ              reduce using rule 66 (exp -> float Binop NUMBER .)
    NOT_EQ          reduce using rule 66 (exp -> float Binop NUMBER .)
    LT              reduce using rule 66 (exp -> float Binop NUMBER .)
    GT              reduce using rule 66 (exp -> float Binop NUMBER .)
    LE              reduce using rule 66 (exp -> float Binop NUMBER .)
    GE              reduce using rule 66 (exp -> float Binop NUMBER .)
    AND             reduce using rule 66 (exp -> float Binop NUMBER .)
    NOT             reduce using rule 66 (exp -> float Binop NUMBER .)
    $end            reduce using rule 66 (exp -> float Binop NUMBER .)
    RPAREN          reduce using rule 66 (exp -> float Binop NUMBER .)
    RBRACKET        reduce using rule 66 (exp -> float Binop NUMBER .)
    RBRACE          reduce using rule 66 (exp -> float Binop NUMBER .)
    RETURN          reduce using rule 66 (exp -> float Binop NUMBER .)
    LBRACE          reduce using rule 66 (exp -> float Binop NUMBER .)
    IF              reduce using rule 66 (exp -> float Binop NUMBER .)
    WHILE           reduce using rule 66 (exp -> float Binop NUMBER .)
    THIS            reduce using rule 66 (exp -> float Binop NUMBER .)
    IDENTIFIER      reduce using rule 66 (exp -> float Binop NUMBER .)
    INT             reduce using rule 66 (exp -> float Binop NUMBER .)
    BOOLEAN         reduce using rule 66 (exp -> float Binop NUMBER .)
    VOID            reduce using rule 66 (exp -> float Binop NUMBER .)
    FLOAT           reduce using rule 66 (exp -> float Binop NUMBER .)
    LPAREN          reduce using rule 66 (exp -> float Binop NUMBER .)
    TRUE            reduce using rule 66 (exp -> float Binop NUMBER .)
    FALSE           reduce using rule 66 (exp -> float Binop NUMBER .)
    NEW             reduce using rule 66 (exp -> float Binop NUMBER .)
    NUMBER          reduce using rule 66 (exp -> float Binop NUMBER .)
    ELSE            reduce using rule 66 (exp -> float Binop NUMBER .)
    SEMICOLON       reduce using rule 66 (exp -> float Binop NUMBER .)
    COMMA           shift and go to state 47

  ! COMMA           [ reduce using rule 66 (exp -> float Binop NUMBER .) ]


state 70

    (29) arraytype -> ClassType LBRACKET RBRACKET .

    IDENTIFIER      reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    LPAREN          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    TRUE            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    FALSE           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    NEW             reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    NUMBER          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    THIS            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    NOT             reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    MINUS           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    INT             reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    BOOLEAN         reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    VOID            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    FLOAT           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    PLUS            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    TIMES           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    EQ              reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    NOT_EQ          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    LT              reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    GT              reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    LE              reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    GE              reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    AND             reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    $end            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    RPAREN          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    COMMA           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    RBRACE          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    RETURN          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    LBRACE          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    IF              reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    WHILE           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    ELSE            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)


state 71

    (27) ClassType -> IDENTIFIER .

    LBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (ClassType -> IDENTIFIER .)


state 72

    (4) ClassDeclaration -> CLASS IDENTIFIER LBRACE RBRACE .

    $end            reduce using rule 4 (ClassDeclaration -> CLASS IDENTIFIER LBRACE RBRACE .)


state 73

    (5) ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration . RBRACE

    RBRACE          shift and go to state 86


state 74

    (6) ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration . RBRACE

    RBRACE          shift and go to state 87


state 75

    (8) MethodDeclaration -> Declarators . IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE
    (9) MethodDeclaration -> Declarators . IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (10) MethodDeclaration -> Declarators . IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators . IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE
    (7) FieldDeclaration -> Declarators . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 88


state 76

    (14) Declarators -> Type .

    IDENTIFIER      reduce using rule 14 (Declarators -> Type .)


state 77

    (15) Declarators -> STATIC . Type
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    Type                           shift and go to state 89
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 78

    (16) Declarators -> PUBLIC . Type
    (18) Declarators -> PUBLIC . STATIC Type
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    STATIC          shift and go to state 91
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    Type                           shift and go to state 90
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 79

    (17) Declarators -> PRIVATE . Type
    (19) Declarators -> PRIVATE . STATIC Type
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    STATIC          shift and go to state 93
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    Type                           shift and go to state 92
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 80

    (53) exp -> Refrence LBRACKET exp RBRACKET .

    PLUS            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    EQ              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NOT_EQ          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LT              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    GT              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LE              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    GE              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    AND             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NOT             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    $end            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    RBRACE          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    RETURN          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LBRACE          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    IF              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    WHILE           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    THIS            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    IDENTIFIER      reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    INT             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    BOOLEAN         reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    VOID            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    FLOAT           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    TRUE            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    FALSE           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NEW             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NUMBER          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)


state 81

    (55) exp -> Refrence LPAREN argumentlist RPAREN .

    PLUS            reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    MINUS           reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    TIMES           reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    DIVIDE          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    EQ              reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    NOT_EQ          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    LT              reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    GT              reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    LE              reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    GE              reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    AND             reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    NOT             reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    $end            reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    RPAREN          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    RBRACKET        reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    COMMA           reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    RBRACE          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    RETURN          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    LBRACE          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    IF              reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    WHILE           reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    THIS            reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    IDENTIFIER      reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    INT             reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    BOOLEAN         reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    VOID            reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    FLOAT           reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    LPAREN          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    TRUE            reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    FALSE           reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    NEW             reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    NUMBER          reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    ELSE            reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)
    SEMICOLON       reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .)


state 82

    (31) argumentlist -> exp COMMA . exp
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    RPAREN          reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 94
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 83

    (61) exp -> NEW IDENTIFIER LPAREN RPAREN .

    PLUS            reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    NOT_EQ          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    NOT             reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    THIS            reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    INT             reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    BOOLEAN         reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    VOID            reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    FLOAT           reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    LPAREN          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    TRUE            reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    FALSE           reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    NEW             reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    NUMBER          reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    ELSE            reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    SEMICOLON       reduce using rule 61 (exp -> NEW IDENTIFIER LPAREN RPAREN .)


state 84

    (63) exp -> NEW IDENTIFIER LBRACKET exp . RBRACKET
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RBRACKET        shift and go to state 95
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 85

    (62) exp -> NEW INT LBRACKET exp . RBRACKET
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RBRACKET        shift and go to state 96
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 86

    (5) ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE .

    $end            reduce using rule 5 (ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE .)


state 87

    (6) ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE .

    $end            reduce using rule 6 (ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE .)


state 88

    (8) MethodDeclaration -> Declarators IDENTIFIER . LPAREN RPAREN LBRACE statement RBRACE
    (9) MethodDeclaration -> Declarators IDENTIFIER . LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (10) MethodDeclaration -> Declarators IDENTIFIER . LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER . LPAREN ParameterList RPAREN LBRACE statement RBRACE
    (7) FieldDeclaration -> Declarators IDENTIFIER . SEMICOLON

    LPAREN          shift and go to state 97
    SEMICOLON       shift and go to state 98


state 89

    (15) Declarators -> STATIC Type .

    IDENTIFIER      reduce using rule 15 (Declarators -> STATIC Type .)


state 90

    (16) Declarators -> PUBLIC Type .

    IDENTIFIER      reduce using rule 16 (Declarators -> PUBLIC Type .)


state 91

    (18) Declarators -> PUBLIC STATIC . Type
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    Type                           shift and go to state 99
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 92

    (17) Declarators -> PRIVATE Type .

    IDENTIFIER      reduce using rule 17 (Declarators -> PRIVATE Type .)


state 93

    (19) Declarators -> PRIVATE STATIC . Type
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    Type                           shift and go to state 100
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 94

    (31) argumentlist -> exp COMMA exp .
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RPAREN          reduce using rule 31 (argumentlist -> exp COMMA exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 95

    (63) exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .

    PLUS            reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    EQ              reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    NOT_EQ          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    LT              reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    GT              reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    LE              reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    GE              reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    AND             reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    NOT             reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    $end            reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    RBRACE          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    RETURN          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    LBRACE          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    IF              reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    WHILE           reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    THIS            reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    IDENTIFIER      reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    INT             reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    BOOLEAN         reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    VOID            reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    FLOAT           reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    TRUE            reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    FALSE           reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    NEW             reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    NUMBER          reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 63 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)


state 96

    (62) exp -> NEW INT LBRACKET exp RBRACKET .

    PLUS            reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    EQ              reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    NOT_EQ          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    LT              reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    GT              reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    LE              reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    GE              reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    AND             reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    NOT             reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    $end            reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    RBRACE          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    RETURN          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    LBRACE          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    IF              reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    WHILE           reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    THIS            reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    IDENTIFIER      reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    INT             reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    BOOLEAN         reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    VOID            reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    FLOAT           reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    TRUE            reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    FALSE           reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    NEW             reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    NUMBER          reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 62 (exp -> NEW INT LBRACKET exp RBRACKET .)


state 97

    (8) MethodDeclaration -> Declarators IDENTIFIER LPAREN . RPAREN LBRACE statement RBRACE
    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN . RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN . ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN . ParameterList RPAREN LBRACE statement RBRACE
    (12) ParameterList -> . Type IDENTIFIER
    (13) ParameterList -> . Type IDENTIFIER COMMA Type IDENTIFIER
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    RPAREN          shift and go to state 101
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    ParameterList                  shift and go to state 102
    Type                           shift and go to state 103
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 98

    (7) FieldDeclaration -> Declarators IDENTIFIER SEMICOLON .

    RBRACE          reduce using rule 7 (FieldDeclaration -> Declarators IDENTIFIER SEMICOLON .)


state 99

    (18) Declarators -> PUBLIC STATIC Type .

    IDENTIFIER      reduce using rule 18 (Declarators -> PUBLIC STATIC Type .)


state 100

    (19) Declarators -> PRIVATE STATIC Type .

    IDENTIFIER      reduce using rule 19 (Declarators -> PRIVATE STATIC Type .)


state 101

    (8) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN . LBRACE statement RBRACE
    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN . LBRACE statement RETURN exp SEMICOLON RBRACE

    LBRACE          shift and go to state 104


state 102

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList . RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList . RPAREN LBRACE statement RBRACE

    RPAREN          shift and go to state 105


state 103

    (12) ParameterList -> Type . IDENTIFIER
    (13) ParameterList -> Type . IDENTIFIER COMMA Type IDENTIFIER

    IDENTIFIER      shift and go to state 106


state 104

    (8) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE . statement RBRACE
    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE . statement RETURN exp SEMICOLON RBRACE
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    statement                      shift and go to state 109
    exp                            shift and go to state 110
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 105

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN . LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN . LBRACE statement RBRACE

    LBRACE          shift and go to state 118


state 106

    (12) ParameterList -> Type IDENTIFIER .
    (13) ParameterList -> Type IDENTIFIER . COMMA Type IDENTIFIER

    RPAREN          reduce using rule 12 (ParameterList -> Type IDENTIFIER .)
    COMMA           shift and go to state 119


state 107

    (33) Refrence -> IDENTIFIER .
    (51) exp -> IDENTIFIER .
    (59) exp -> IDENTIFIER . Binop NUMBER
    (27) ClassType -> IDENTIFIER .
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

  ! reduce/reduce conflict for LPAREN resolved using rule 33 (Refrence -> IDENTIFIER .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for TRUE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for FALSE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NEW resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NUMBER resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for THIS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for INT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for VOID resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for EQ resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for GT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for GE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for RETURN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    ASSIGN          reduce using rule 33 (Refrence -> IDENTIFIER .)
    LBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (ClassType -> IDENTIFIER .)
    LPAREN          reduce using rule 27 (ClassType -> IDENTIFIER .)
    TRUE            reduce using rule 27 (ClassType -> IDENTIFIER .)
    FALSE           reduce using rule 27 (ClassType -> IDENTIFIER .)
    NEW             reduce using rule 27 (ClassType -> IDENTIFIER .)
    NUMBER          reduce using rule 27 (ClassType -> IDENTIFIER .)
    THIS            reduce using rule 27 (ClassType -> IDENTIFIER .)
    INT             reduce using rule 27 (ClassType -> IDENTIFIER .)
    BOOLEAN         reduce using rule 27 (ClassType -> IDENTIFIER .)
    VOID            reduce using rule 27 (ClassType -> IDENTIFIER .)
    FLOAT           reduce using rule 27 (ClassType -> IDENTIFIER .)
    RBRACE          reduce using rule 27 (ClassType -> IDENTIFIER .)
    RETURN          reduce using rule 27 (ClassType -> IDENTIFIER .)
    LBRACE          reduce using rule 27 (ClassType -> IDENTIFIER .)
    IF              reduce using rule 27 (ClassType -> IDENTIFIER .)
    WHILE           reduce using rule 27 (ClassType -> IDENTIFIER .)
    ELSE            reduce using rule 27 (ClassType -> IDENTIFIER .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

  ! LPAREN          [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! LBRACKET        [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! EQ              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NOT_EQ          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LT              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! GT              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LE              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! GE              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! RBRACE          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! RETURN          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! THIS            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! INT             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! BOOLEAN         [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! VOID            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! FLOAT           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! TRUE            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! FALSE           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NEW             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NUMBER          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! EQ              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! NOT_EQ          [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! LT              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! GT              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! LE              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! GE              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]

    Binop                          shift and go to state 40

state 108

    (37) statement -> LBRACE . statement RBRACE
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    statement                      shift and go to state 120
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    exp                            shift and go to state 110
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 109

    (8) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement . RBRACE
    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement . RETURN exp SEMICOLON RBRACE
    (44) statement -> statement . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACE          shift and go to state 122
    RETURN          shift and go to state 123
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]
  ! RBRACE          [ reduce using rule 49 (exp -> .) ]
  ! RETURN          [ reduce using rule 49 (exp -> .) ]

    statement                      shift and go to state 121
    exp                            shift and go to state 110
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 110

    (45) statement -> exp .
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    RBRACE          reduce using rule 45 (statement -> exp .)
    RETURN          reduce using rule 45 (statement -> exp .)
    LBRACE          reduce using rule 45 (statement -> exp .)
    IF              reduce using rule 45 (statement -> exp .)
    WHILE           reduce using rule 45 (statement -> exp .)
    THIS            reduce using rule 45 (statement -> exp .)
    IDENTIFIER      reduce using rule 45 (statement -> exp .)
    INT             reduce using rule 45 (statement -> exp .)
    BOOLEAN         reduce using rule 45 (statement -> exp .)
    VOID            reduce using rule 45 (statement -> exp .)
    FLOAT           reduce using rule 45 (statement -> exp .)
    LPAREN          reduce using rule 45 (statement -> exp .)
    TRUE            reduce using rule 45 (statement -> exp .)
    FALSE           reduce using rule 45 (statement -> exp .)
    NEW             reduce using rule 45 (statement -> exp .)
    NUMBER          reduce using rule 45 (statement -> exp .)
    ELSE            reduce using rule 45 (statement -> exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

  ! NOT             [ reduce using rule 45 (statement -> exp .) ]
  ! MINUS           [ reduce using rule 45 (statement -> exp .) ]
  ! PLUS            [ reduce using rule 45 (statement -> exp .) ]
  ! TIMES           [ reduce using rule 45 (statement -> exp .) ]
  ! DIVIDE          [ reduce using rule 45 (statement -> exp .) ]
  ! EQ              [ reduce using rule 45 (statement -> exp .) ]
  ! NOT_EQ          [ reduce using rule 45 (statement -> exp .) ]
  ! LT              [ reduce using rule 45 (statement -> exp .) ]
  ! GT              [ reduce using rule 45 (statement -> exp .) ]
  ! LE              [ reduce using rule 45 (statement -> exp .) ]
  ! GE              [ reduce using rule 45 (statement -> exp .) ]
  ! AND             [ reduce using rule 45 (statement -> exp .) ]

    Binop                          shift and go to state 26

state 111

    (34) statement -> empty .

    RBRACE          reduce using rule 34 (statement -> empty .)
    RETURN          reduce using rule 34 (statement -> empty .)
    LBRACE          reduce using rule 34 (statement -> empty .)
    IF              reduce using rule 34 (statement -> empty .)
    WHILE           reduce using rule 34 (statement -> empty .)
    THIS            reduce using rule 34 (statement -> empty .)
    IDENTIFIER      reduce using rule 34 (statement -> empty .)
    INT             reduce using rule 34 (statement -> empty .)
    BOOLEAN         reduce using rule 34 (statement -> empty .)
    VOID            reduce using rule 34 (statement -> empty .)
    FLOAT           reduce using rule 34 (statement -> empty .)
    LPAREN          reduce using rule 34 (statement -> empty .)
    TRUE            reduce using rule 34 (statement -> empty .)
    FALSE           reduce using rule 34 (statement -> empty .)
    NEW             reduce using rule 34 (statement -> empty .)
    NUMBER          reduce using rule 34 (statement -> empty .)
    NOT             reduce using rule 34 (statement -> empty .)
    MINUS           reduce using rule 34 (statement -> empty .)
    PLUS            reduce using rule 34 (statement -> empty .)
    TIMES           reduce using rule 34 (statement -> empty .)
    DIVIDE          reduce using rule 34 (statement -> empty .)
    EQ              reduce using rule 34 (statement -> empty .)
    NOT_EQ          reduce using rule 34 (statement -> empty .)
    LT              reduce using rule 34 (statement -> empty .)
    GT              reduce using rule 34 (statement -> empty .)
    LE              reduce using rule 34 (statement -> empty .)
    GE              reduce using rule 34 (statement -> empty .)
    AND             reduce using rule 34 (statement -> empty .)
    ELSE            reduce using rule 34 (statement -> empty .)


state 112

    (35) statement -> if_st .

    RBRACE          reduce using rule 35 (statement -> if_st .)
    RETURN          reduce using rule 35 (statement -> if_st .)
    LBRACE          reduce using rule 35 (statement -> if_st .)
    IF              reduce using rule 35 (statement -> if_st .)
    WHILE           reduce using rule 35 (statement -> if_st .)
    THIS            reduce using rule 35 (statement -> if_st .)
    IDENTIFIER      reduce using rule 35 (statement -> if_st .)
    INT             reduce using rule 35 (statement -> if_st .)
    BOOLEAN         reduce using rule 35 (statement -> if_st .)
    VOID            reduce using rule 35 (statement -> if_st .)
    FLOAT           reduce using rule 35 (statement -> if_st .)
    LPAREN          reduce using rule 35 (statement -> if_st .)
    TRUE            reduce using rule 35 (statement -> if_st .)
    FALSE           reduce using rule 35 (statement -> if_st .)
    NEW             reduce using rule 35 (statement -> if_st .)
    NUMBER          reduce using rule 35 (statement -> if_st .)
    NOT             reduce using rule 35 (statement -> if_st .)
    MINUS           reduce using rule 35 (statement -> if_st .)
    PLUS            reduce using rule 35 (statement -> if_st .)
    TIMES           reduce using rule 35 (statement -> if_st .)
    DIVIDE          reduce using rule 35 (statement -> if_st .)
    EQ              reduce using rule 35 (statement -> if_st .)
    NOT_EQ          reduce using rule 35 (statement -> if_st .)
    LT              reduce using rule 35 (statement -> if_st .)
    GT              reduce using rule 35 (statement -> if_st .)
    LE              reduce using rule 35 (statement -> if_st .)
    GE              reduce using rule 35 (statement -> if_st .)
    AND             reduce using rule 35 (statement -> if_st .)
    ELSE            reduce using rule 35 (statement -> if_st .)


state 113

    (36) statement -> while_st .

    RBRACE          reduce using rule 36 (statement -> while_st .)
    RETURN          reduce using rule 36 (statement -> while_st .)
    LBRACE          reduce using rule 36 (statement -> while_st .)
    IF              reduce using rule 36 (statement -> while_st .)
    WHILE           reduce using rule 36 (statement -> while_st .)
    THIS            reduce using rule 36 (statement -> while_st .)
    IDENTIFIER      reduce using rule 36 (statement -> while_st .)
    INT             reduce using rule 36 (statement -> while_st .)
    BOOLEAN         reduce using rule 36 (statement -> while_st .)
    VOID            reduce using rule 36 (statement -> while_st .)
    FLOAT           reduce using rule 36 (statement -> while_st .)
    LPAREN          reduce using rule 36 (statement -> while_st .)
    TRUE            reduce using rule 36 (statement -> while_st .)
    FALSE           reduce using rule 36 (statement -> while_st .)
    NEW             reduce using rule 36 (statement -> while_st .)
    NUMBER          reduce using rule 36 (statement -> while_st .)
    NOT             reduce using rule 36 (statement -> while_st .)
    MINUS           reduce using rule 36 (statement -> while_st .)
    PLUS            reduce using rule 36 (statement -> while_st .)
    TIMES           reduce using rule 36 (statement -> while_st .)
    DIVIDE          reduce using rule 36 (statement -> while_st .)
    EQ              reduce using rule 36 (statement -> while_st .)
    NOT_EQ          reduce using rule 36 (statement -> while_st .)
    LT              reduce using rule 36 (statement -> while_st .)
    GT              reduce using rule 36 (statement -> while_st .)
    LE              reduce using rule 36 (statement -> while_st .)
    GE              reduce using rule 36 (statement -> while_st .)
    AND             reduce using rule 36 (statement -> while_st .)
    ELSE            reduce using rule 36 (statement -> while_st .)


state 114

    (38) statement -> Refrence . LPAREN argumentlist RPAREN
    (39) statement -> Refrence . LPAREN RPAREN SEMICOLON
    (40) statement -> Refrence . LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> Refrence . ASSIGN exp SEMICOLON
    (53) exp -> Refrence . LBRACKET exp RBRACKET
    (54) exp -> Refrence . LPAREN RPAREN
    (55) exp -> Refrence . LPAREN argumentlist RPAREN

    LPAREN          shift and go to state 124
    LBRACKET        shift and go to state 125
    ASSIGN          shift and go to state 126


state 115

    (42) statement -> PrimeType . IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> PrimeType . IDENTIFIER ASSIGN exp SEMICOLON
    (20) Type -> PrimeType .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 127
    LPAREN          reduce using rule 20 (Type -> PrimeType .)
    TRUE            reduce using rule 20 (Type -> PrimeType .)
    FALSE           reduce using rule 20 (Type -> PrimeType .)
    NEW             reduce using rule 20 (Type -> PrimeType .)
    NUMBER          reduce using rule 20 (Type -> PrimeType .)
    THIS            reduce using rule 20 (Type -> PrimeType .)
    NOT             reduce using rule 20 (Type -> PrimeType .)
    MINUS           reduce using rule 20 (Type -> PrimeType .)
    INT             reduce using rule 20 (Type -> PrimeType .)
    BOOLEAN         reduce using rule 20 (Type -> PrimeType .)
    VOID            reduce using rule 20 (Type -> PrimeType .)
    FLOAT           reduce using rule 20 (Type -> PrimeType .)
    PLUS            reduce using rule 20 (Type -> PrimeType .)
    TIMES           reduce using rule 20 (Type -> PrimeType .)
    DIVIDE          reduce using rule 20 (Type -> PrimeType .)
    EQ              reduce using rule 20 (Type -> PrimeType .)
    NOT_EQ          reduce using rule 20 (Type -> PrimeType .)
    LT              reduce using rule 20 (Type -> PrimeType .)
    GT              reduce using rule 20 (Type -> PrimeType .)
    LE              reduce using rule 20 (Type -> PrimeType .)
    GE              reduce using rule 20 (Type -> PrimeType .)
    AND             reduce using rule 20 (Type -> PrimeType .)
    RBRACE          reduce using rule 20 (Type -> PrimeType .)
    RETURN          reduce using rule 20 (Type -> PrimeType .)
    LBRACE          reduce using rule 20 (Type -> PrimeType .)
    IF              reduce using rule 20 (Type -> PrimeType .)
    WHILE           reduce using rule 20 (Type -> PrimeType .)
    ELSE            reduce using rule 20 (Type -> PrimeType .)

  ! IDENTIFIER      [ reduce using rule 20 (Type -> PrimeType .) ]


state 116

    (47) if_st -> IF . LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> IF . LPAREN exp RPAREN statement

    LPAREN          shift and go to state 128


state 117

    (46) while_st -> WHILE . LPAREN exp RPAREN statement

    LPAREN          shift and go to state 129


state 118

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE . statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE . statement RBRACE
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    statement                      shift and go to state 130
    exp                            shift and go to state 110
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 119

    (13) ParameterList -> Type IDENTIFIER COMMA . Type IDENTIFIER
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    IDENTIFIER      shift and go to state 71

    Type                           shift and go to state 131
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 120

    (37) statement -> LBRACE statement . RBRACE
    (44) statement -> statement . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACE          shift and go to state 132
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]
  ! RBRACE          [ reduce using rule 49 (exp -> .) ]

    statement                      shift and go to state 121
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    exp                            shift and go to state 110
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 121

    (44) statement -> statement statement .
    (44) statement -> statement . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! reduce/reduce conflict for IF resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for THIS resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for INT resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for VOID resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NEW resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NOT resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for PLUS resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for EQ resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for LT resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for GT resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for LE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for GE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for AND resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (statement -> statement statement .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for EQ resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for LT resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for GT resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for LE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for GE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for AND resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NOT resolved using rule 44 (statement -> statement statement .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NEW resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 44 (statement -> statement statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (statement -> statement statement .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACE          reduce using rule 44 (statement -> statement statement .)
    RETURN          reduce using rule 44 (statement -> statement statement .)
    PLUS            reduce using rule 44 (statement -> statement statement .)
    TIMES           reduce using rule 44 (statement -> statement statement .)
    DIVIDE          reduce using rule 44 (statement -> statement statement .)
    EQ              reduce using rule 44 (statement -> statement statement .)
    NOT_EQ          reduce using rule 44 (statement -> statement statement .)
    LT              reduce using rule 44 (statement -> statement statement .)
    GT              reduce using rule 44 (statement -> statement statement .)
    LE              reduce using rule 44 (statement -> statement statement .)
    GE              reduce using rule 44 (statement -> statement statement .)
    AND             reduce using rule 44 (statement -> statement statement .)
    ELSE            reduce using rule 44 (statement -> statement statement .)
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 44 (statement -> statement statement .) ]
  ! IF              [ reduce using rule 44 (statement -> statement statement .) ]
  ! WHILE           [ reduce using rule 44 (statement -> statement statement .) ]
  ! THIS            [ reduce using rule 44 (statement -> statement statement .) ]
  ! IDENTIFIER      [ reduce using rule 44 (statement -> statement statement .) ]
  ! INT             [ reduce using rule 44 (statement -> statement statement .) ]
  ! BOOLEAN         [ reduce using rule 44 (statement -> statement statement .) ]
  ! VOID            [ reduce using rule 44 (statement -> statement statement .) ]
  ! FLOAT           [ reduce using rule 44 (statement -> statement statement .) ]
  ! LPAREN          [ reduce using rule 44 (statement -> statement statement .) ]
  ! TRUE            [ reduce using rule 44 (statement -> statement statement .) ]
  ! FALSE           [ reduce using rule 44 (statement -> statement statement .) ]
  ! NEW             [ reduce using rule 44 (statement -> statement statement .) ]
  ! NUMBER          [ reduce using rule 44 (statement -> statement statement .) ]
  ! NOT             [ reduce using rule 44 (statement -> statement statement .) ]
  ! MINUS           [ reduce using rule 44 (statement -> statement statement .) ]
  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! ELSE            [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 49 (exp -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! TIMES           [ reduce using rule 49 (exp -> .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> .) ]
  ! EQ              [ reduce using rule 49 (exp -> .) ]
  ! NOT_EQ          [ reduce using rule 49 (exp -> .) ]
  ! LT              [ reduce using rule 49 (exp -> .) ]
  ! GT              [ reduce using rule 49 (exp -> .) ]
  ! LE              [ reduce using rule 49 (exp -> .) ]
  ! GE              [ reduce using rule 49 (exp -> .) ]
  ! AND             [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]
  ! RBRACE          [ reduce using rule 49 (exp -> .) ]
  ! RETURN          [ reduce using rule 49 (exp -> .) ]
  ! ELSE            [ reduce using rule 49 (exp -> .) ]

    statement                      shift and go to state 121
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    exp                            shift and go to state 110
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 122

    (8) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE .

    RBRACE          reduce using rule 8 (MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE .)


state 123

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN . exp SEMICOLON RBRACE
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 133
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 124

    (38) statement -> Refrence LPAREN . argumentlist RPAREN
    (39) statement -> Refrence LPAREN . RPAREN SEMICOLON
    (54) exp -> Refrence LPAREN . RPAREN
    (55) exp -> Refrence LPAREN . argumentlist RPAREN
    (30) argumentlist -> . exp
    (31) argumentlist -> . exp COMMA exp
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RPAREN          shift and go to state 135
    COMMA           reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! RPAREN          [ reduce using rule 49 (exp -> .) ]

    Refrence                       shift and go to state 8
    argumentlist                   shift and go to state 134
    exp                            shift and go to state 59
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 125

    (40) statement -> Refrence LBRACKET . exp RBRACKET ASSIGN exp SEMICOLON
    (53) exp -> Refrence LBRACKET . exp RBRACKET
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    Refrence                       shift and go to state 8
    exp                            shift and go to state 136
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 126

    (41) statement -> Refrence ASSIGN . exp SEMICOLON
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    Refrence                       shift and go to state 8
    exp                            shift and go to state 137
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 127

    (42) statement -> PrimeType IDENTIFIER . ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> PrimeType IDENTIFIER . ASSIGN exp SEMICOLON

    ASSIGN          shift and go to state 138


state 128

    (47) if_st -> IF LPAREN . exp RPAREN statement ELSE statement
    (48) if_st -> IF LPAREN . exp RPAREN statement
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RPAREN          reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 139
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 129

    (46) while_st -> WHILE LPAREN . exp RPAREN statement
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RPAREN          reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 140
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 130

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement . RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement . RBRACE
    (44) statement -> statement . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RETURN          shift and go to state 141
    RBRACE          shift and go to state 142
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]
  ! RETURN          [ reduce using rule 49 (exp -> .) ]
  ! RBRACE          [ reduce using rule 49 (exp -> .) ]

    statement                      shift and go to state 121
    exp                            shift and go to state 110
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 131

    (13) ParameterList -> Type IDENTIFIER COMMA Type . IDENTIFIER

    IDENTIFIER      shift and go to state 143


state 132

    (37) statement -> LBRACE statement RBRACE .

    RBRACE          reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    LBRACE          reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    IF              reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    WHILE           reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    THIS            reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    IDENTIFIER      reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    INT             reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    BOOLEAN         reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    VOID            reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    FLOAT           reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    LPAREN          reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    TRUE            reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    FALSE           reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    NEW             reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    NUMBER          reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    NOT             reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    MINUS           reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    PLUS            reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    TIMES           reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    DIVIDE          reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    EQ              reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    NOT_EQ          reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    LT              reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    GT              reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    LE              reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    GE              reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    AND             reduce using rule 37 (statement -> LBRACE statement RBRACE .)
    ELSE            reduce using rule 37 (statement -> LBRACE statement RBRACE .)


state 133

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp . SEMICOLON RBRACE
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    SEMICOLON       shift and go to state 144
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 134

    (38) statement -> Refrence LPAREN argumentlist . RPAREN
    (55) exp -> Refrence LPAREN argumentlist . RPAREN

    RPAREN          shift and go to state 145


state 135

    (39) statement -> Refrence LPAREN RPAREN . SEMICOLON
    (54) exp -> Refrence LPAREN RPAREN .

    SEMICOLON       shift and go to state 146
    PLUS            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    MINUS           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    TIMES           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    DIVIDE          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    EQ              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NOT_EQ          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LT              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    GT              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LE              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    GE              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    AND             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NOT             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    RBRACE          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    RETURN          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LBRACE          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    IF              reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    WHILE           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    THIS            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    INT             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    BOOLEAN         reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    VOID            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    FLOAT           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    LPAREN          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    TRUE            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    FALSE           reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NEW             reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    NUMBER          reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)
    ELSE            reduce using rule 54 (exp -> Refrence LPAREN RPAREN .)


state 136

    (40) statement -> Refrence LBRACKET exp . RBRACKET ASSIGN exp SEMICOLON
    (53) exp -> Refrence LBRACKET exp . RBRACKET
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RBRACKET        shift and go to state 147
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 137

    (41) statement -> Refrence ASSIGN exp . SEMICOLON
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    SEMICOLON       shift and go to state 148
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 138

    (42) statement -> PrimeType IDENTIFIER ASSIGN . IDENTIFIER SEMICOLON
    (43) statement -> PrimeType IDENTIFIER ASSIGN . exp SEMICOLON
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      shift and go to state 149
    SEMICOLON       reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    PrimeType                      shift and go to state 17
    exp                            shift and go to state 150
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 139

    (47) if_st -> IF LPAREN exp . RPAREN statement ELSE statement
    (48) if_st -> IF LPAREN exp . RPAREN statement
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RPAREN          shift and go to state 151
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 140

    (46) while_st -> WHILE LPAREN exp . RPAREN statement
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    RPAREN          shift and go to state 152
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 141

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN . exp SEMICOLON RBRACE
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 153
    Type                           shift and go to state 7
    Refrence                       shift and go to state 8
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 142

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE .

    RBRACE          reduce using rule 11 (MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE .)


state 143

    (13) ParameterList -> Type IDENTIFIER COMMA Type IDENTIFIER .

    RPAREN          reduce using rule 13 (ParameterList -> Type IDENTIFIER COMMA Type IDENTIFIER .)


state 144

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON . RBRACE

    RBRACE          shift and go to state 154


state 145

    (38) statement -> Refrence LPAREN argumentlist RPAREN .
    (55) exp -> Refrence LPAREN argumentlist RPAREN .

  ! reduce/reduce conflict for PLUS resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for MINUS resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for TIMES resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for EQ resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for LT resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for GT resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for LE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for GE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for AND resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for NOT resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for LBRACE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for WHILE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for THIS resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for INT resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for VOID resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for FLOAT resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for LPAREN resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for TRUE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for FALSE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for NEW resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for NUMBER resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
  ! reduce/reduce conflict for ELSE resolved using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    RBRACE          reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    RETURN          reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    LBRACE          reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    IF              reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    WHILE           reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    THIS            reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    IDENTIFIER      reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    INT             reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    BOOLEAN         reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    VOID            reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    FLOAT           reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    LPAREN          reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    TRUE            reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    FALSE           reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    NEW             reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    NUMBER          reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    NOT             reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    MINUS           reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    PLUS            reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    TIMES           reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    DIVIDE          reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    EQ              reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    NOT_EQ          reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    LT              reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    GT              reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    LE              reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    GE              reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    AND             reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)
    ELSE            reduce using rule 38 (statement -> Refrence LPAREN argumentlist RPAREN .)

  ! PLUS            [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! MINUS           [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! TIMES           [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! DIVIDE          [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! EQ              [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! NOT_EQ          [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! LT              [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! GT              [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! LE              [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! GE              [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! AND             [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! NOT             [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! RBRACE          [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! RETURN          [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! LBRACE          [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! IF              [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! WHILE           [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! THIS            [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! IDENTIFIER      [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! INT             [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! BOOLEAN         [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! VOID            [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! FLOAT           [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! LPAREN          [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! TRUE            [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! FALSE           [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! NEW             [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! NUMBER          [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]
  ! ELSE            [ reduce using rule 55 (exp -> Refrence LPAREN argumentlist RPAREN .) ]


state 146

    (39) statement -> Refrence LPAREN RPAREN SEMICOLON .

    RBRACE          reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    THIS            reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    LPAREN          reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    TRUE            reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    FALSE           reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    NEW             reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    NUMBER          reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    NOT             reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    MINUS           reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    PLUS            reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    TIMES           reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    DIVIDE          reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    EQ              reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    NOT_EQ          reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    LT              reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    GT              reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    LE              reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    GE              reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    AND             reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 39 (statement -> Refrence LPAREN RPAREN SEMICOLON .)


state 147

    (40) statement -> Refrence LBRACKET exp RBRACKET . ASSIGN exp SEMICOLON
    (53) exp -> Refrence LBRACKET exp RBRACKET .

    ASSIGN          shift and go to state 155
    PLUS            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    EQ              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NOT_EQ          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LT              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    GT              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LE              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    GE              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    AND             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NOT             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    RBRACE          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    RETURN          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LBRACE          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    IF              reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    WHILE           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    THIS            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    IDENTIFIER      reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    INT             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    BOOLEAN         reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    VOID            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    FLOAT           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    TRUE            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    FALSE           reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NEW             reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    NUMBER          reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)
    ELSE            reduce using rule 53 (exp -> Refrence LBRACKET exp RBRACKET .)


state 148

    (41) statement -> Refrence ASSIGN exp SEMICOLON .

    RBRACE          reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    LBRACE          reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    IF              reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    THIS            reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    INT             reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    BOOLEAN         reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    VOID            reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    FLOAT           reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    LPAREN          reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    TRUE            reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    FALSE           reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    NEW             reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    NUMBER          reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    NOT             reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    MINUS           reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    PLUS            reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    TIMES           reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    DIVIDE          reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    EQ              reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    NOT_EQ          reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    LT              reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    GT              reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    LE              reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    GE              reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    AND             reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 41 (statement -> Refrence ASSIGN exp SEMICOLON .)


state 149

    (42) statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER . SEMICOLON
    (51) exp -> IDENTIFIER .
    (59) exp -> IDENTIFIER . Binop NUMBER
    (33) Refrence -> IDENTIFIER .
    (27) ClassType -> IDENTIFIER .
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for EQ resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for GT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for GE resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    SEMICOLON       shift and go to state 156
    LBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (ClassType -> IDENTIFIER .)
    LPAREN          reduce using rule 27 (ClassType -> IDENTIFIER .)
    TRUE            reduce using rule 27 (ClassType -> IDENTIFIER .)
    FALSE           reduce using rule 27 (ClassType -> IDENTIFIER .)
    NEW             reduce using rule 27 (ClassType -> IDENTIFIER .)
    NUMBER          reduce using rule 27 (ClassType -> IDENTIFIER .)
    THIS            reduce using rule 27 (ClassType -> IDENTIFIER .)
    INT             reduce using rule 27 (ClassType -> IDENTIFIER .)
    BOOLEAN         reduce using rule 27 (ClassType -> IDENTIFIER .)
    VOID            reduce using rule 27 (ClassType -> IDENTIFIER .)
    FLOAT           reduce using rule 27 (ClassType -> IDENTIFIER .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

  ! SEMICOLON       [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! EQ              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NOT_EQ          [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LT              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! GT              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LE              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! GE              [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 51 (exp -> IDENTIFIER .) ]
  ! LBRACKET        [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! EQ              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! NOT_EQ          [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! LT              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! GT              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! LE              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! GE              [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! SEMICOLON       [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]

    Binop                          shift and go to state 40

state 150

    (43) statement -> PrimeType IDENTIFIER ASSIGN exp . SEMICOLON
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    SEMICOLON       shift and go to state 157
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 151

    (47) if_st -> IF LPAREN exp RPAREN . statement ELSE statement
    (48) if_st -> IF LPAREN exp RPAREN . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    ELSE            reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! ELSE            [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 110
    statement                      shift and go to state 158
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 152

    (46) while_st -> WHILE LPAREN exp RPAREN . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    ELSE            reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! ELSE            [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 110
    statement                      shift and go to state 159
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 153

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp . SEMICOLON RBRACE
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    SEMICOLON       shift and go to state 160
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 154

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .

    RBRACE          reduce using rule 9 (MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .)


state 155

    (40) statement -> Refrence LBRACKET exp RBRACKET ASSIGN . exp SEMICOLON
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 49 (exp -> .)
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    IDENTIFIER      shift and go to state 6
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    THIS            shift and go to state 20
    NOT             shift and go to state 21
    MINUS           shift and go to state 22
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25

  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]

    Refrence                       shift and go to state 8
    exp                            shift and go to state 161
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 156

    (42) statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .

    RBRACE          reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    IF              reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    THIS            reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    INT             reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    NEW             reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    NUMBER          reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    PLUS            reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    TIMES           reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    DIVIDE          reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    EQ              reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    NOT_EQ          reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    LT              reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    GT              reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    LE              reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    GE              reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    AND             reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)
    ELSE            reduce using rule 42 (statement -> PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON .)


state 157

    (43) statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .

    RBRACE          reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    LBRACE          reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    IF              reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    THIS            reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    IDENTIFIER      reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    INT             reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    BOOLEAN         reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    VOID            reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    FLOAT           reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    LPAREN          reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    TRUE            reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    FALSE           reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    NEW             reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    NUMBER          reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    NOT             reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    MINUS           reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    PLUS            reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    TIMES           reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    DIVIDE          reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    EQ              reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    NOT_EQ          reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    LT              reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    GT              reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    LE              reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    GE              reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    AND             reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 43 (statement -> PrimeType IDENTIFIER ASSIGN exp SEMICOLON .)


state 158

    (47) if_st -> IF LPAREN exp RPAREN statement . ELSE statement
    (48) if_st -> IF LPAREN exp RPAREN statement .
    (44) statement -> statement . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! reduce/reduce conflict for IF resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for THIS resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for INT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for VOID resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NEW resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for PLUS resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for EQ resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for AND resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for EQ resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for AND resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NEW resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    ELSE            shift and go to state 162
    RBRACE          reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    RETURN          reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    PLUS            reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    TIMES           reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    DIVIDE          reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    EQ              reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    NOT_EQ          reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    LT              reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    GT              reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    LE              reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    GE              reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    AND             reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .)
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! IF              [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! WHILE           [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! THIS            [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! IDENTIFIER      [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! INT             [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! BOOLEAN         [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! VOID            [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! FLOAT           [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! LPAREN          [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! TRUE            [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! FALSE           [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! NEW             [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! NUMBER          [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! NOT             [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! MINUS           [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! ELSE            [ reduce using rule 48 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! ELSE            [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 49 (exp -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! TIMES           [ reduce using rule 49 (exp -> .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> .) ]
  ! EQ              [ reduce using rule 49 (exp -> .) ]
  ! NOT_EQ          [ reduce using rule 49 (exp -> .) ]
  ! LT              [ reduce using rule 49 (exp -> .) ]
  ! GT              [ reduce using rule 49 (exp -> .) ]
  ! LE              [ reduce using rule 49 (exp -> .) ]
  ! GE              [ reduce using rule 49 (exp -> .) ]
  ! AND             [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]
  ! RBRACE          [ reduce using rule 49 (exp -> .) ]
  ! RETURN          [ reduce using rule 49 (exp -> .) ]
  ! ELSE            [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 110
    statement                      shift and go to state 121
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 159

    (46) while_st -> WHILE LPAREN exp RPAREN statement .
    (44) statement -> statement . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! reduce/reduce conflict for IF resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for THIS resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for INT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for VOID resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NEW resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for PLUS resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for EQ resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for AND resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for EQ resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for LE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for GE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for AND resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NOT resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NEW resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACE          reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    RETURN          reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    PLUS            reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    TIMES           reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    DIVIDE          reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    EQ              reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    NOT_EQ          reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    LT              reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    GT              reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    LE              reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    GE              reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    AND             reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    ELSE            reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .)
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! IF              [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! WHILE           [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! THIS            [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! IDENTIFIER      [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! INT             [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! BOOLEAN         [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! VOID            [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! FLOAT           [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! LPAREN          [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! TRUE            [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! FALSE           [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! NEW             [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! NUMBER          [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! NOT             [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! MINUS           [ reduce using rule 46 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! ELSE            [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 49 (exp -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! TIMES           [ reduce using rule 49 (exp -> .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> .) ]
  ! EQ              [ reduce using rule 49 (exp -> .) ]
  ! NOT_EQ          [ reduce using rule 49 (exp -> .) ]
  ! LT              [ reduce using rule 49 (exp -> .) ]
  ! GT              [ reduce using rule 49 (exp -> .) ]
  ! LE              [ reduce using rule 49 (exp -> .) ]
  ! GE              [ reduce using rule 49 (exp -> .) ]
  ! AND             [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]
  ! RBRACE          [ reduce using rule 49 (exp -> .) ]
  ! RETURN          [ reduce using rule 49 (exp -> .) ]
  ! ELSE            [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 110
    statement                      shift and go to state 121
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 160

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON . RBRACE

    RBRACE          shift and go to state 163


state 161

    (40) statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp . SEMICOLON
    (50) exp -> exp . Binop exp
    (71) Binop -> . PLUS
    (72) Binop -> . MINUS
    (73) Binop -> . TIMES
    (74) Binop -> . DIVIDE
    (75) Binop -> . EQ
    (76) Binop -> . NOT_EQ
    (77) Binop -> . LT
    (78) Binop -> . GT
    (79) Binop -> . LE
    (80) Binop -> . GE
    (81) Binop -> . AND
    (82) Binop -> . NOT

    SEMICOLON       shift and go to state 164
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    NOT_EQ          shift and go to state 32
    LT              shift and go to state 33
    GT              shift and go to state 34
    LE              shift and go to state 35
    GE              shift and go to state 36
    AND             shift and go to state 37
    NOT             shift and go to state 38

    Binop                          shift and go to state 26

state 162

    (47) if_st -> IF LPAREN exp RPAREN statement ELSE . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TIMES resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GT resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for LE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for GE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for AND resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NOT resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NEW resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for NUMBER resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 49 (exp -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 49 (exp -> .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    PLUS            reduce using rule 49 (exp -> .)
    TIMES           reduce using rule 49 (exp -> .)
    DIVIDE          reduce using rule 49 (exp -> .)
    EQ              reduce using rule 49 (exp -> .)
    NOT_EQ          reduce using rule 49 (exp -> .)
    LT              reduce using rule 49 (exp -> .)
    GT              reduce using rule 49 (exp -> .)
    LE              reduce using rule 49 (exp -> .)
    GE              reduce using rule 49 (exp -> .)
    AND             reduce using rule 49 (exp -> .)
    RBRACE          reduce using rule 49 (exp -> .)
    RETURN          reduce using rule 49 (exp -> .)
    ELSE            reduce using rule 49 (exp -> .)
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! ELSE            [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 110
    statement                      shift and go to state 165
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 163

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .

    RBRACE          reduce using rule 10 (MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .)


state 164

    (40) statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .

    RBRACE          reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    LBRACE          reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    IF              reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    THIS            reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    INT             reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    BOOLEAN         reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    VOID            reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    FLOAT           reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    LPAREN          reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    TRUE            reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    FALSE           reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    NEW             reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    NUMBER          reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    NOT             reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    MINUS           reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    PLUS            reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    TIMES           reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    DIVIDE          reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    EQ              reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    NOT_EQ          reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    LT              reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    GT              reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    LE              reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    GE              reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    AND             reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 40 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)


state 165

    (47) if_st -> IF LPAREN exp RPAREN statement ELSE statement .
    (44) statement -> statement . statement
    (34) statement -> . empty
    (35) statement -> . if_st
    (36) statement -> . while_st
    (37) statement -> . LBRACE statement RBRACE
    (38) statement -> . Refrence LPAREN argumentlist RPAREN
    (39) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (40) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (41) statement -> . Refrence ASSIGN exp SEMICOLON
    (42) statement -> . PrimeType IDENTIFIER ASSIGN IDENTIFIER SEMICOLON
    (43) statement -> . PrimeType IDENTIFIER ASSIGN exp SEMICOLON
    (44) statement -> . statement statement
    (45) statement -> . exp
    (83) empty -> .
    (47) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (48) if_st -> . IF LPAREN exp RPAREN statement
    (46) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (23) PrimeType -> . INT
    (24) PrimeType -> . BOOLEAN
    (25) PrimeType -> . VOID
    (26) PrimeType -> . FLOAT
    (49) exp -> .
    (50) exp -> . exp Binop exp
    (51) exp -> . IDENTIFIER
    (52) exp -> . Type exp
    (53) exp -> . Refrence LBRACKET exp RBRACKET
    (54) exp -> . Refrence LPAREN RPAREN
    (55) exp -> . Refrence LPAREN argumentlist RPAREN
    (56) exp -> . Unop exp
    (57) exp -> . LPAREN exp RPAREN
    (58) exp -> . TRUE
    (59) exp -> . IDENTIFIER Binop NUMBER
    (60) exp -> . FALSE
    (61) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (62) exp -> . NEW INT LBRACKET exp RBRACKET
    (63) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (64) exp -> . NUMBER Binop NUMBER
    (65) exp -> . NUMBER Binop float
    (66) exp -> . float Binop NUMBER
    (67) exp -> . float Binop float
    (20) Type -> . PrimeType
    (21) Type -> . ClassType
    (22) Type -> . arraytype
    (68) Unop -> . NOT
    (69) Unop -> . MINUS
    (70) float -> . NUMBER COMMA NUMBER
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! reduce/reduce conflict for IF resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for THIS resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for INT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for VOID resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NEW resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NOT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for PLUS resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for EQ resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for LT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for GT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for LE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for GE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for AND resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for PLUS resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for TIMES resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for EQ resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NOT_EQ resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for LT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for GT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for LE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for GE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for AND resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NOT resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NEW resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for NUMBER resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACE          reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    RETURN          reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    PLUS            reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    TIMES           reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    DIVIDE          reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    EQ              reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    NOT_EQ          reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    LT              reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    GT              reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    LE              reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    GE              reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    AND             reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    ELSE            reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    LBRACE          shift and go to state 108
    IF              shift and go to state 116
    WHILE           shift and go to state 117
    THIS            shift and go to state 20
    IDENTIFIER      shift and go to state 107
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 23
    VOID            shift and go to state 24
    FLOAT           shift and go to state 25
    LPAREN          shift and go to state 9
    TRUE            shift and go to state 11
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    NUMBER          shift and go to state 12
    NOT             shift and go to state 21
    MINUS           shift and go to state 22

  ! LBRACE          [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! IF              [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! WHILE           [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! THIS            [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! IDENTIFIER      [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! INT             [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! BOOLEAN         [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! VOID            [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! FLOAT           [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! LPAREN          [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! TRUE            [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! FALSE           [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! NEW             [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! NUMBER          [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! NOT             [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! MINUS           [ reduce using rule 47 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! LBRACE          [ reduce using rule 83 (empty -> .) ]
  ! IF              [ reduce using rule 83 (empty -> .) ]
  ! WHILE           [ reduce using rule 83 (empty -> .) ]
  ! THIS            [ reduce using rule 83 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 83 (empty -> .) ]
  ! INT             [ reduce using rule 83 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 83 (empty -> .) ]
  ! VOID            [ reduce using rule 83 (empty -> .) ]
  ! FLOAT           [ reduce using rule 83 (empty -> .) ]
  ! LPAREN          [ reduce using rule 83 (empty -> .) ]
  ! TRUE            [ reduce using rule 83 (empty -> .) ]
  ! FALSE           [ reduce using rule 83 (empty -> .) ]
  ! NEW             [ reduce using rule 83 (empty -> .) ]
  ! NUMBER          [ reduce using rule 83 (empty -> .) ]
  ! NOT             [ reduce using rule 83 (empty -> .) ]
  ! MINUS           [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 83 (empty -> .) ]
  ! TIMES           [ reduce using rule 83 (empty -> .) ]
  ! DIVIDE          [ reduce using rule 83 (empty -> .) ]
  ! EQ              [ reduce using rule 83 (empty -> .) ]
  ! NOT_EQ          [ reduce using rule 83 (empty -> .) ]
  ! LT              [ reduce using rule 83 (empty -> .) ]
  ! GT              [ reduce using rule 83 (empty -> .) ]
  ! LE              [ reduce using rule 83 (empty -> .) ]
  ! GE              [ reduce using rule 83 (empty -> .) ]
  ! AND             [ reduce using rule 83 (empty -> .) ]
  ! RBRACE          [ reduce using rule 83 (empty -> .) ]
  ! RETURN          [ reduce using rule 83 (empty -> .) ]
  ! ELSE            [ reduce using rule 83 (empty -> .) ]
  ! PLUS            [ reduce using rule 49 (exp -> .) ]
  ! MINUS           [ reduce using rule 49 (exp -> .) ]
  ! TIMES           [ reduce using rule 49 (exp -> .) ]
  ! DIVIDE          [ reduce using rule 49 (exp -> .) ]
  ! EQ              [ reduce using rule 49 (exp -> .) ]
  ! NOT_EQ          [ reduce using rule 49 (exp -> .) ]
  ! LT              [ reduce using rule 49 (exp -> .) ]
  ! GT              [ reduce using rule 49 (exp -> .) ]
  ! LE              [ reduce using rule 49 (exp -> .) ]
  ! GE              [ reduce using rule 49 (exp -> .) ]
  ! AND             [ reduce using rule 49 (exp -> .) ]
  ! NOT             [ reduce using rule 49 (exp -> .) ]
  ! LBRACE          [ reduce using rule 49 (exp -> .) ]
  ! IF              [ reduce using rule 49 (exp -> .) ]
  ! WHILE           [ reduce using rule 49 (exp -> .) ]
  ! THIS            [ reduce using rule 49 (exp -> .) ]
  ! IDENTIFIER      [ reduce using rule 49 (exp -> .) ]
  ! INT             [ reduce using rule 49 (exp -> .) ]
  ! BOOLEAN         [ reduce using rule 49 (exp -> .) ]
  ! VOID            [ reduce using rule 49 (exp -> .) ]
  ! FLOAT           [ reduce using rule 49 (exp -> .) ]
  ! LPAREN          [ reduce using rule 49 (exp -> .) ]
  ! TRUE            [ reduce using rule 49 (exp -> .) ]
  ! FALSE           [ reduce using rule 49 (exp -> .) ]
  ! NEW             [ reduce using rule 49 (exp -> .) ]
  ! NUMBER          [ reduce using rule 49 (exp -> .) ]
  ! RBRACE          [ reduce using rule 49 (exp -> .) ]
  ! RETURN          [ reduce using rule 49 (exp -> .) ]
  ! ELSE            [ reduce using rule 49 (exp -> .) ]

    exp                            shift and go to state 110
    statement                      shift and go to state 121
    empty                          shift and go to state 111
    if_st                          shift and go to state 112
    while_st                       shift and go to state 113
    Refrence                       shift and go to state 114
    PrimeType                      shift and go to state 115
    Type                           shift and go to state 7
    Unop                           shift and go to state 10
    float                          shift and go to state 16
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 6 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 6 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 6 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 6 resolved as shift
WARNING: shift/reduce conflict for EQ in state 6 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 6 resolved as shift
WARNING: shift/reduce conflict for LT in state 6 resolved as shift
WARNING: shift/reduce conflict for GT in state 6 resolved as shift
WARNING: shift/reduce conflict for LE in state 6 resolved as shift
WARNING: shift/reduce conflict for GE in state 6 resolved as shift
WARNING: shift/reduce conflict for AND in state 6 resolved as shift
WARNING: shift/reduce conflict for NOT in state 6 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 7 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 7 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 7 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 7 resolved as shift
WARNING: shift/reduce conflict for NEW in state 7 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 7 resolved as shift
WARNING: shift/reduce conflict for THIS in state 7 resolved as shift
WARNING: shift/reduce conflict for NOT in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for INT in state 7 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 7 resolved as shift
WARNING: shift/reduce conflict for VOID in state 7 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 7 resolved as shift
WARNING: shift/reduce conflict for NOT in state 9 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 9 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 10 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 10 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 10 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 10 resolved as shift
WARNING: shift/reduce conflict for NEW in state 10 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 10 resolved as shift
WARNING: shift/reduce conflict for THIS in state 10 resolved as shift
WARNING: shift/reduce conflict for NOT in state 10 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 10 resolved as shift
WARNING: shift/reduce conflict for INT in state 10 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 10 resolved as shift
WARNING: shift/reduce conflict for VOID in state 10 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 10 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 26 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 26 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 26 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 26 resolved as shift
WARNING: shift/reduce conflict for NEW in state 26 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 26 resolved as shift
WARNING: shift/reduce conflict for THIS in state 26 resolved as shift
WARNING: shift/reduce conflict for NOT in state 26 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 26 resolved as shift
WARNING: shift/reduce conflict for INT in state 26 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 26 resolved as shift
WARNING: shift/reduce conflict for VOID in state 26 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 26 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 41 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 41 resolved as shift
WARNING: shift/reduce conflict for EQ in state 41 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 41 resolved as shift
WARNING: shift/reduce conflict for LT in state 41 resolved as shift
WARNING: shift/reduce conflict for GT in state 41 resolved as shift
WARNING: shift/reduce conflict for LE in state 41 resolved as shift
WARNING: shift/reduce conflict for GE in state 41 resolved as shift
WARNING: shift/reduce conflict for AND in state 41 resolved as shift
WARNING: shift/reduce conflict for NOT in state 41 resolved as shift
WARNING: shift/reduce conflict for NOT in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 43 resolved as shift
WARNING: shift/reduce conflict for NOT in state 43 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 43 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 45 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 45 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 45 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 45 resolved as shift
WARNING: shift/reduce conflict for EQ in state 45 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 45 resolved as shift
WARNING: shift/reduce conflict for LT in state 45 resolved as shift
WARNING: shift/reduce conflict for GT in state 45 resolved as shift
WARNING: shift/reduce conflict for LE in state 45 resolved as shift
WARNING: shift/reduce conflict for GE in state 45 resolved as shift
WARNING: shift/reduce conflict for AND in state 45 resolved as shift
WARNING: shift/reduce conflict for NOT in state 45 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 53 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 53 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 53 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 53 resolved as shift
WARNING: shift/reduce conflict for EQ in state 53 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 53 resolved as shift
WARNING: shift/reduce conflict for LT in state 53 resolved as shift
WARNING: shift/reduce conflict for GT in state 53 resolved as shift
WARNING: shift/reduce conflict for LE in state 53 resolved as shift
WARNING: shift/reduce conflict for GE in state 53 resolved as shift
WARNING: shift/reduce conflict for AND in state 53 resolved as shift
WARNING: shift/reduce conflict for NOT in state 53 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 61 resolved as shift
WARNING: shift/reduce conflict for NOT in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for NOT in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 69 resolved as shift
WARNING: shift/reduce conflict for NOT in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 104 resolved as shift
WARNING: shift/reduce conflict for IF in state 104 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 104 resolved as shift
WARNING: shift/reduce conflict for THIS in state 104 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 104 resolved as shift
WARNING: shift/reduce conflict for INT in state 104 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 104 resolved as shift
WARNING: shift/reduce conflict for VOID in state 104 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 104 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 104 resolved as shift
WARNING: shift/reduce conflict for IF in state 104 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 104 resolved as shift
WARNING: shift/reduce conflict for THIS in state 104 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 104 resolved as shift
WARNING: shift/reduce conflict for INT in state 104 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 104 resolved as shift
WARNING: shift/reduce conflict for VOID in state 104 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 104 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 104 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 104 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 104 resolved as shift
WARNING: shift/reduce conflict for NEW in state 104 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 107 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 107 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 107 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 107 resolved as shift
WARNING: shift/reduce conflict for EQ in state 107 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 107 resolved as shift
WARNING: shift/reduce conflict for LT in state 107 resolved as shift
WARNING: shift/reduce conflict for GT in state 107 resolved as shift
WARNING: shift/reduce conflict for LE in state 107 resolved as shift
WARNING: shift/reduce conflict for GE in state 107 resolved as shift
WARNING: shift/reduce conflict for AND in state 107 resolved as shift
WARNING: shift/reduce conflict for NOT in state 107 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 108 resolved as shift
WARNING: shift/reduce conflict for IF in state 108 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 108 resolved as shift
WARNING: shift/reduce conflict for THIS in state 108 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 108 resolved as shift
WARNING: shift/reduce conflict for INT in state 108 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 108 resolved as shift
WARNING: shift/reduce conflict for VOID in state 108 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 108 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 108 resolved as shift
WARNING: shift/reduce conflict for IF in state 108 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 108 resolved as shift
WARNING: shift/reduce conflict for THIS in state 108 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 108 resolved as shift
WARNING: shift/reduce conflict for INT in state 108 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 108 resolved as shift
WARNING: shift/reduce conflict for VOID in state 108 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 108 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 108 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 108 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 108 resolved as shift
WARNING: shift/reduce conflict for NEW in state 108 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT in state 108 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 108 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 109 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 109 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 109 resolved as shift
WARNING: shift/reduce conflict for IF in state 109 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 109 resolved as shift
WARNING: shift/reduce conflict for THIS in state 109 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 109 resolved as shift
WARNING: shift/reduce conflict for INT in state 109 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 109 resolved as shift
WARNING: shift/reduce conflict for VOID in state 109 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 109 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 109 resolved as shift
WARNING: shift/reduce conflict for IF in state 109 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 109 resolved as shift
WARNING: shift/reduce conflict for THIS in state 109 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 109 resolved as shift
WARNING: shift/reduce conflict for INT in state 109 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 109 resolved as shift
WARNING: shift/reduce conflict for VOID in state 109 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 109 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 109 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 109 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 109 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 109 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 109 resolved as shift
WARNING: shift/reduce conflict for NEW in state 109 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 110 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 110 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 110 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 110 resolved as shift
WARNING: shift/reduce conflict for EQ in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 110 resolved as shift
WARNING: shift/reduce conflict for LT in state 110 resolved as shift
WARNING: shift/reduce conflict for GT in state 110 resolved as shift
WARNING: shift/reduce conflict for LE in state 110 resolved as shift
WARNING: shift/reduce conflict for GE in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 110 resolved as shift
WARNING: shift/reduce conflict for NOT in state 110 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 115 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 118 resolved as shift
WARNING: shift/reduce conflict for IF in state 118 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 118 resolved as shift
WARNING: shift/reduce conflict for THIS in state 118 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 118 resolved as shift
WARNING: shift/reduce conflict for INT in state 118 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 118 resolved as shift
WARNING: shift/reduce conflict for VOID in state 118 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 118 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 118 resolved as shift
WARNING: shift/reduce conflict for IF in state 118 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 118 resolved as shift
WARNING: shift/reduce conflict for THIS in state 118 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 118 resolved as shift
WARNING: shift/reduce conflict for INT in state 118 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 118 resolved as shift
WARNING: shift/reduce conflict for VOID in state 118 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 118 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 118 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 118 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 118 resolved as shift
WARNING: shift/reduce conflict for NEW in state 118 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 118 resolved as shift
WARNING: shift/reduce conflict for NOT in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 120 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 120 resolved as shift
WARNING: shift/reduce conflict for IF in state 120 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 120 resolved as shift
WARNING: shift/reduce conflict for THIS in state 120 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 120 resolved as shift
WARNING: shift/reduce conflict for INT in state 120 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 120 resolved as shift
WARNING: shift/reduce conflict for VOID in state 120 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 120 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 120 resolved as shift
WARNING: shift/reduce conflict for IF in state 120 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 120 resolved as shift
WARNING: shift/reduce conflict for THIS in state 120 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 120 resolved as shift
WARNING: shift/reduce conflict for INT in state 120 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 120 resolved as shift
WARNING: shift/reduce conflict for VOID in state 120 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 120 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 120 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 120 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 120 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 120 resolved as shift
WARNING: shift/reduce conflict for NEW in state 120 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 120 resolved as shift
WARNING: shift/reduce conflict for NOT in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 121 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 121 resolved as shift
WARNING: shift/reduce conflict for IF in state 121 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 121 resolved as shift
WARNING: shift/reduce conflict for THIS in state 121 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 121 resolved as shift
WARNING: shift/reduce conflict for INT in state 121 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 121 resolved as shift
WARNING: shift/reduce conflict for VOID in state 121 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 121 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 121 resolved as shift
WARNING: shift/reduce conflict for IF in state 121 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 121 resolved as shift
WARNING: shift/reduce conflict for THIS in state 121 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 121 resolved as shift
WARNING: shift/reduce conflict for INT in state 121 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 121 resolved as shift
WARNING: shift/reduce conflict for VOID in state 121 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 121 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 121 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 121 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 121 resolved as shift
WARNING: shift/reduce conflict for NEW in state 121 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT in state 123 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 123 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 124 resolved as shift
WARNING: shift/reduce conflict for NOT in state 124 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 124 resolved as shift
WARNING: shift/reduce conflict for NOT in state 125 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 125 resolved as shift
WARNING: shift/reduce conflict for NOT in state 126 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 126 resolved as shift
WARNING: shift/reduce conflict for NOT in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for NOT in state 129 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 129 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 130 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 130 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 130 resolved as shift
WARNING: shift/reduce conflict for IF in state 130 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 130 resolved as shift
WARNING: shift/reduce conflict for THIS in state 130 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 130 resolved as shift
WARNING: shift/reduce conflict for INT in state 130 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 130 resolved as shift
WARNING: shift/reduce conflict for VOID in state 130 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 130 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 130 resolved as shift
WARNING: shift/reduce conflict for IF in state 130 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 130 resolved as shift
WARNING: shift/reduce conflict for THIS in state 130 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 130 resolved as shift
WARNING: shift/reduce conflict for INT in state 130 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 130 resolved as shift
WARNING: shift/reduce conflict for VOID in state 130 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 130 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 130 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 130 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 130 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 130 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 130 resolved as shift
WARNING: shift/reduce conflict for NEW in state 130 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 130 resolved as shift
WARNING: shift/reduce conflict for NOT in state 130 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 130 resolved as shift
WARNING: shift/reduce conflict for NOT in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for NOT in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 141 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 149 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for EQ in state 149 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 149 resolved as shift
WARNING: shift/reduce conflict for LT in state 149 resolved as shift
WARNING: shift/reduce conflict for GT in state 149 resolved as shift
WARNING: shift/reduce conflict for LE in state 149 resolved as shift
WARNING: shift/reduce conflict for GE in state 149 resolved as shift
WARNING: shift/reduce conflict for AND in state 149 resolved as shift
WARNING: shift/reduce conflict for NOT in state 149 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 151 resolved as shift
WARNING: shift/reduce conflict for IF in state 151 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 151 resolved as shift
WARNING: shift/reduce conflict for THIS in state 151 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 151 resolved as shift
WARNING: shift/reduce conflict for INT in state 151 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 151 resolved as shift
WARNING: shift/reduce conflict for VOID in state 151 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 151 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 151 resolved as shift
WARNING: shift/reduce conflict for IF in state 151 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 151 resolved as shift
WARNING: shift/reduce conflict for THIS in state 151 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 151 resolved as shift
WARNING: shift/reduce conflict for INT in state 151 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 151 resolved as shift
WARNING: shift/reduce conflict for VOID in state 151 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 151 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 151 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 151 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 151 resolved as shift
WARNING: shift/reduce conflict for NEW in state 151 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 151 resolved as shift
WARNING: shift/reduce conflict for NOT in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 152 resolved as shift
WARNING: shift/reduce conflict for IF in state 152 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 152 resolved as shift
WARNING: shift/reduce conflict for THIS in state 152 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 152 resolved as shift
WARNING: shift/reduce conflict for INT in state 152 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 152 resolved as shift
WARNING: shift/reduce conflict for VOID in state 152 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 152 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 152 resolved as shift
WARNING: shift/reduce conflict for IF in state 152 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 152 resolved as shift
WARNING: shift/reduce conflict for THIS in state 152 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 152 resolved as shift
WARNING: shift/reduce conflict for INT in state 152 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 152 resolved as shift
WARNING: shift/reduce conflict for VOID in state 152 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 152 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 152 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 152 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 152 resolved as shift
WARNING: shift/reduce conflict for NEW in state 152 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 152 resolved as shift
WARNING: shift/reduce conflict for NOT in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for NOT in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 158 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 158 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 158 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 158 resolved as shift
WARNING: shift/reduce conflict for IF in state 158 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 158 resolved as shift
WARNING: shift/reduce conflict for THIS in state 158 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 158 resolved as shift
WARNING: shift/reduce conflict for INT in state 158 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 158 resolved as shift
WARNING: shift/reduce conflict for VOID in state 158 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 158 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 158 resolved as shift
WARNING: shift/reduce conflict for IF in state 158 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 158 resolved as shift
WARNING: shift/reduce conflict for THIS in state 158 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 158 resolved as shift
WARNING: shift/reduce conflict for INT in state 158 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 158 resolved as shift
WARNING: shift/reduce conflict for VOID in state 158 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 158 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 158 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 158 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 158 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 158 resolved as shift
WARNING: shift/reduce conflict for NEW in state 158 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 158 resolved as shift
WARNING: shift/reduce conflict for NOT in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 159 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 159 resolved as shift
WARNING: shift/reduce conflict for THIS in state 159 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 159 resolved as shift
WARNING: shift/reduce conflict for INT in state 159 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 159 resolved as shift
WARNING: shift/reduce conflict for VOID in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 159 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 159 resolved as shift
WARNING: shift/reduce conflict for THIS in state 159 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 159 resolved as shift
WARNING: shift/reduce conflict for INT in state 159 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 159 resolved as shift
WARNING: shift/reduce conflict for VOID in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 159 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 159 resolved as shift
WARNING: shift/reduce conflict for NEW in state 159 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 159 resolved as shift
WARNING: shift/reduce conflict for NOT in state 159 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 159 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 162 resolved as shift
WARNING: shift/reduce conflict for IF in state 162 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 162 resolved as shift
WARNING: shift/reduce conflict for THIS in state 162 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 162 resolved as shift
WARNING: shift/reduce conflict for INT in state 162 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 162 resolved as shift
WARNING: shift/reduce conflict for VOID in state 162 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 162 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 162 resolved as shift
WARNING: shift/reduce conflict for IF in state 162 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 162 resolved as shift
WARNING: shift/reduce conflict for THIS in state 162 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 162 resolved as shift
WARNING: shift/reduce conflict for INT in state 162 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 162 resolved as shift
WARNING: shift/reduce conflict for VOID in state 162 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 162 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 162 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 162 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 162 resolved as shift
WARNING: shift/reduce conflict for NEW in state 162 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 162 resolved as shift
WARNING: shift/reduce conflict for NOT in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 165 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for THIS in state 165 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 165 resolved as shift
WARNING: shift/reduce conflict for INT in state 165 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 165 resolved as shift
WARNING: shift/reduce conflict for VOID in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for THIS in state 165 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 165 resolved as shift
WARNING: shift/reduce conflict for INT in state 165 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 165 resolved as shift
WARNING: shift/reduce conflict for VOID in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 165 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 165 resolved as shift
WARNING: shift/reduce conflict for NEW in state 165 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 165 resolved as shift
WARNING: shift/reduce conflict for NOT in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 6 resolved using rule (Refrence -> IDENTIFIER)
WARNING: rejected rule (exp -> IDENTIFIER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (Refrence -> IDENTIFIER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (exp -> IDENTIFIER) in state 6
WARNING: reduce/reduce conflict in state 104 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 104
WARNING: reduce/reduce conflict in state 107 resolved using rule (Refrence -> IDENTIFIER)
WARNING: rejected rule (exp -> IDENTIFIER) in state 107
WARNING: reduce/reduce conflict in state 107 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (Refrence -> IDENTIFIER) in state 107
WARNING: reduce/reduce conflict in state 107 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (exp -> IDENTIFIER) in state 107
WARNING: reduce/reduce conflict in state 108 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 108
WARNING: reduce/reduce conflict in state 109 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 109
WARNING: reduce/reduce conflict in state 118 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 118
WARNING: reduce/reduce conflict in state 120 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 120
WARNING: reduce/reduce conflict in state 121 resolved using rule (statement -> statement statement)
WARNING: rejected rule (empty -> <empty>) in state 121
WARNING: reduce/reduce conflict in state 121 resolved using rule (statement -> statement statement)
WARNING: rejected rule (exp -> <empty>) in state 121
WARNING: reduce/reduce conflict in state 130 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 130
WARNING: reduce/reduce conflict in state 145 resolved using rule (statement -> Refrence LPAREN argumentlist RPAREN)
WARNING: rejected rule (exp -> Refrence LPAREN argumentlist RPAREN) in state 145
WARNING: reduce/reduce conflict in state 149 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (Refrence -> IDENTIFIER) in state 149
WARNING: reduce/reduce conflict in state 149 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (exp -> IDENTIFIER) in state 149
WARNING: reduce/reduce conflict in state 151 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 151
WARNING: reduce/reduce conflict in state 152 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 152
WARNING: reduce/reduce conflict in state 158 resolved using rule (if_st -> IF LPAREN exp RPAREN statement)
WARNING: rejected rule (empty -> <empty>) in state 158
WARNING: reduce/reduce conflict in state 158 resolved using rule (if_st -> IF LPAREN exp RPAREN statement)
WARNING: rejected rule (exp -> <empty>) in state 158
WARNING: reduce/reduce conflict in state 159 resolved using rule (while_st -> WHILE LPAREN exp RPAREN statement)
WARNING: rejected rule (empty -> <empty>) in state 159
WARNING: reduce/reduce conflict in state 159 resolved using rule (while_st -> WHILE LPAREN exp RPAREN statement)
WARNING: rejected rule (exp -> <empty>) in state 159
WARNING: reduce/reduce conflict in state 162 resolved using rule (exp -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 162
WARNING: reduce/reduce conflict in state 165 resolved using rule (if_st -> IF LPAREN exp RPAREN statement ELSE statement)
WARNING: rejected rule (empty -> <empty>) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (if_st -> IF LPAREN exp RPAREN statement ELSE statement)
WARNING: rejected rule (exp -> <empty>) in state 165
WARNING: Rule (empty -> <empty>) is never reduced
WARNING: Rule (exp -> IDENTIFIER) is never reduced
