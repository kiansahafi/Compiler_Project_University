Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHAR
    DO
    FOR
    MAIN
    PLUSASSIGN

Grammar

Rule 0     S' -> start
Rule 1     start -> ClassDeclaration
Rule 2     start -> empty
Rule 3     start -> exp
Rule 4     start -> ClassDeclaration ClassDeclaration
Rule 5     ClassDeclaration -> CLASS IDENTIFIER LBRACE RBRACE
Rule 6     ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE
Rule 7     ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE
Rule 8     FieldDeclaration -> Declarators IDENTIFIER SEMICOLON
Rule 9     MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE
Rule 10    MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
Rule 11    MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
Rule 12    MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE
Rule 13    ParameterList -> Type IDENTIFIER
Rule 14    ParameterList -> Type IDENTIFIER COMMA Type IDENTIFIER
Rule 15    Declarators -> Type
Rule 16    Declarators -> STATIC Type
Rule 17    Declarators -> PUBLIC Type
Rule 18    Declarators -> PRIVATE Type
Rule 19    Declarators -> PUBLIC STATIC Type
Rule 20    Declarators -> PRIVATE STATIC Type
Rule 21    Type -> PrimeType
Rule 22    Type -> ClassType
Rule 23    Type -> arraytype
Rule 24    PrimeType -> INT
Rule 25    PrimeType -> BOOLEAN
Rule 26    PrimeType -> VOID
Rule 27    ClassType -> IDENTIFIER
Rule 28    arraytype -> INT LBRACKET RBRACKET
Rule 29    arraytype -> ClassType LBRACKET RBRACKET
Rule 30    argumentlist -> exp
Rule 31    argumentlist -> exp COMMA exp
Rule 32    Refrence -> THIS
Rule 33    Refrence -> IDENTIFIER
Rule 34    statement -> if_st
Rule 35    statement -> while_st
Rule 36    statement -> LBRACE statement RBRACE
Rule 37    statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON
Rule 38    statement -> Refrence LPAREN RPAREN SEMICOLON
Rule 39    statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
Rule 40    statement -> Refrence ASSIGN exp SEMICOLON
Rule 41    statement -> Type IDENTIFIER ASSIGN exp SEMICOLON
Rule 42    statement -> empty
Rule 43    statement -> statement statement
Rule 44    while_st -> WHILE LPAREN exp RPAREN statement
Rule 45    if_st -> IF LPAREN exp RPAREN statement
Rule 46    if_st -> IF LPAREN exp RPAREN statement ELSE statement
Rule 47    exp -> Refrence
Rule 48    exp -> Type exp
Rule 49    exp -> Refrence LBRACKET exp RBRACKET
Rule 50    exp -> Refrence LPAREN RPAREN
Rule 51    exp -> Refrence LPAREN argumentlist RPAREN
Rule 52    exp -> Unop exp
Rule 53    exp -> exp Binop exp
Rule 54    exp -> LPAREN exp RPAREN
Rule 55    exp -> NUMBER
Rule 56    exp -> TRUE
Rule 57    exp -> IDENTIFIER Binop NUMBER
Rule 58    exp -> FALSE
Rule 59    exp -> NEW IDENTIFIER LPAREN RPAREN
Rule 60    exp -> NEW INT LBRACKET exp RBRACKET
Rule 61    exp -> NEW IDENTIFIER LBRACKET exp RBRACKET
Rule 62    Unop -> NOT
Rule 63    Unop -> MINUS
Rule 64    Binop -> PLUS
Rule 65    Binop -> MINUS
Rule 66    Binop -> TIMES
Rule 67    Binop -> DIVIDE
Rule 68    Binop -> EQ
Rule 69    Binop -> NOT_EQ
Rule 70    Binop -> LT
Rule 71    Binop -> GT
Rule 72    Binop -> LE
Rule 73    Binop -> GE
Rule 74    Binop -> AND
Rule 75    Binop -> NOT
Rule 76    empty -> <empty>

Terminals, with rules where they appear

AND                  : 74
ASSIGN               : 39 40 41
BOOLEAN              : 25
CHAR                 : 
CLASS                : 5 6 7
COMMA                : 14 31
DIVIDE               : 67
DO                   : 
ELSE                 : 46
EQ                   : 68
FALSE                : 58
FOR                  : 
GE                   : 73
GT                   : 71
IDENTIFIER           : 5 6 7 8 9 10 11 12 13 14 14 27 33 41 57 59 61
IF                   : 45 46
INT                  : 24 28 60
LBRACE               : 5 6 7 9 10 11 12 36
LBRACKET             : 28 29 39 49 60 61
LE                   : 72
LPAREN               : 9 10 11 12 37 38 44 45 46 50 51 54 59
LT                   : 70
MAIN                 : 
MINUS                : 63 65
NEW                  : 59 60 61
NOT                  : 62 75
NOT_EQ               : 69
NUMBER               : 55 57
PLUS                 : 64
PLUSASSIGN           : 
PRIVATE              : 18 20
PUBLIC               : 17 19
RBRACE               : 5 6 7 9 10 11 12 36
RBRACKET             : 28 29 39 49 60 61
RETURN               : 10 11
RPAREN               : 9 10 11 12 37 38 44 45 46 50 51 54 59
SEMICOLON            : 8 10 11 37 38 39 40 41
STATIC               : 16 19 20
THIS                 : 32
TIMES                : 66
TRUE                 : 56
VOID                 : 26
WHILE                : 44
error                : 

Nonterminals, with rules where they appear

Binop                : 53 57
ClassDeclaration     : 1 4 4
ClassType            : 22 29
Declarators          : 8 9 10 11 12
FieldDeclaration     : 7
MethodDeclaration    : 6
ParameterList        : 11 12
PrimeType            : 21
Refrence             : 37 38 39 40 47 49 50 51
Type                 : 13 14 14 15 16 17 18 19 20 41 48
Unop                 : 52
argumentlist         : 37 51
arraytype            : 23
empty                : 2 42
exp                  : 3 10 11 30 31 31 39 39 40 41 44 45 46 48 49 52 53 53 54 60 61
if_st                : 34
start                : 0
statement            : 9 10 11 12 36 43 43 44 45 46 46
while_st             : 35

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . ClassDeclaration
    (2) start -> . empty
    (3) start -> . exp
    (4) start -> . ClassDeclaration ClassDeclaration
    (5) ClassDeclaration -> . CLASS IDENTIFIER LBRACE RBRACE
    (6) ClassDeclaration -> . CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE
    (7) ClassDeclaration -> . CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE
    (76) empty -> .
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    CLASS           shift and go to state 5
    $end            reduce using rule 76 (empty -> .)
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    start                          shift and go to state 1
    ClassDeclaration               shift and go to state 2
    empty                          shift and go to state 3
    exp                            shift and go to state 4
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 1

    (0) S' -> start .



state 2

    (1) start -> ClassDeclaration .
    (4) start -> ClassDeclaration . ClassDeclaration
    (5) ClassDeclaration -> . CLASS IDENTIFIER LBRACE RBRACE
    (6) ClassDeclaration -> . CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE
    (7) ClassDeclaration -> . CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE

    $end            reduce using rule 1 (start -> ClassDeclaration .)
    CLASS           shift and go to state 5

    ClassDeclaration               shift and go to state 24

state 3

    (2) start -> empty .

    $end            reduce using rule 2 (start -> empty .)


state 4

    (3) start -> exp .
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    $end            reduce using rule 3 (start -> exp .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 5

    (5) ClassDeclaration -> CLASS . IDENTIFIER LBRACE RBRACE
    (6) ClassDeclaration -> CLASS . IDENTIFIER LBRACE MethodDeclaration RBRACE
    (7) ClassDeclaration -> CLASS . IDENTIFIER LBRACE FieldDeclaration RBRACE

    IDENTIFIER      shift and go to state 38


state 6

    (57) exp -> IDENTIFIER . Binop NUMBER
    (33) Refrence -> IDENTIFIER .
    (27) ClassType -> IDENTIFIER .
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 27 (ClassType -> IDENTIFIER .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 33 (Refrence -> IDENTIFIER .)
    RPAREN          reduce using rule 33 (Refrence -> IDENTIFIER .)
    RBRACKET        reduce using rule 33 (Refrence -> IDENTIFIER .)
    COMMA           reduce using rule 33 (Refrence -> IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (Refrence -> IDENTIFIER .)
    LBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    LPAREN          reduce using rule 27 (ClassType -> IDENTIFIER .)
    NUMBER          reduce using rule 27 (ClassType -> IDENTIFIER .)
    TRUE            reduce using rule 27 (ClassType -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (ClassType -> IDENTIFIER .)
    FALSE           reduce using rule 27 (ClassType -> IDENTIFIER .)
    NEW             reduce using rule 27 (ClassType -> IDENTIFIER .)
    THIS            reduce using rule 27 (ClassType -> IDENTIFIER .)
    INT             reduce using rule 27 (ClassType -> IDENTIFIER .)
    BOOLEAN         reduce using rule 27 (ClassType -> IDENTIFIER .)
    VOID            reduce using rule 27 (ClassType -> IDENTIFIER .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

  ! LBRACKET        [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! EQ              [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! NOT_EQ          [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! LT              [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! GT              [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! LE              [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! GE              [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]
  ! NOT             [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 27 (ClassType -> IDENTIFIER .) ]

    Binop                          shift and go to state 39

state 7

    (47) exp -> Refrence .
    (49) exp -> Refrence . LBRACKET exp RBRACKET
    (50) exp -> Refrence . LPAREN RPAREN
    (51) exp -> Refrence . LPAREN argumentlist RPAREN

    PLUS            reduce using rule 47 (exp -> Refrence .)
    MINUS           reduce using rule 47 (exp -> Refrence .)
    TIMES           reduce using rule 47 (exp -> Refrence .)
    DIVIDE          reduce using rule 47 (exp -> Refrence .)
    EQ              reduce using rule 47 (exp -> Refrence .)
    NOT_EQ          reduce using rule 47 (exp -> Refrence .)
    LT              reduce using rule 47 (exp -> Refrence .)
    GT              reduce using rule 47 (exp -> Refrence .)
    LE              reduce using rule 47 (exp -> Refrence .)
    GE              reduce using rule 47 (exp -> Refrence .)
    AND             reduce using rule 47 (exp -> Refrence .)
    NOT             reduce using rule 47 (exp -> Refrence .)
    $end            reduce using rule 47 (exp -> Refrence .)
    RPAREN          reduce using rule 47 (exp -> Refrence .)
    RBRACKET        reduce using rule 47 (exp -> Refrence .)
    COMMA           reduce using rule 47 (exp -> Refrence .)
    SEMICOLON       reduce using rule 47 (exp -> Refrence .)
    LBRACKET        shift and go to state 40
    LPAREN          shift and go to state 41


state 8

    (48) exp -> Type . exp
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Type                           shift and go to state 8
    exp                            shift and go to state 42
    Refrence                       shift and go to state 7
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 9

    (54) exp -> LPAREN . exp RPAREN
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 43
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 10

    (52) exp -> Unop . exp
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Unop                           shift and go to state 10
    exp                            shift and go to state 44
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 11

    (55) exp -> NUMBER .

    PLUS            reduce using rule 55 (exp -> NUMBER .)
    MINUS           reduce using rule 55 (exp -> NUMBER .)
    TIMES           reduce using rule 55 (exp -> NUMBER .)
    DIVIDE          reduce using rule 55 (exp -> NUMBER .)
    EQ              reduce using rule 55 (exp -> NUMBER .)
    NOT_EQ          reduce using rule 55 (exp -> NUMBER .)
    LT              reduce using rule 55 (exp -> NUMBER .)
    GT              reduce using rule 55 (exp -> NUMBER .)
    LE              reduce using rule 55 (exp -> NUMBER .)
    GE              reduce using rule 55 (exp -> NUMBER .)
    AND             reduce using rule 55 (exp -> NUMBER .)
    NOT             reduce using rule 55 (exp -> NUMBER .)
    $end            reduce using rule 55 (exp -> NUMBER .)
    RPAREN          reduce using rule 55 (exp -> NUMBER .)
    RBRACKET        reduce using rule 55 (exp -> NUMBER .)
    COMMA           reduce using rule 55 (exp -> NUMBER .)
    SEMICOLON       reduce using rule 55 (exp -> NUMBER .)


state 12

    (56) exp -> TRUE .

    PLUS            reduce using rule 56 (exp -> TRUE .)
    MINUS           reduce using rule 56 (exp -> TRUE .)
    TIMES           reduce using rule 56 (exp -> TRUE .)
    DIVIDE          reduce using rule 56 (exp -> TRUE .)
    EQ              reduce using rule 56 (exp -> TRUE .)
    NOT_EQ          reduce using rule 56 (exp -> TRUE .)
    LT              reduce using rule 56 (exp -> TRUE .)
    GT              reduce using rule 56 (exp -> TRUE .)
    LE              reduce using rule 56 (exp -> TRUE .)
    GE              reduce using rule 56 (exp -> TRUE .)
    AND             reduce using rule 56 (exp -> TRUE .)
    NOT             reduce using rule 56 (exp -> TRUE .)
    $end            reduce using rule 56 (exp -> TRUE .)
    RPAREN          reduce using rule 56 (exp -> TRUE .)
    RBRACKET        reduce using rule 56 (exp -> TRUE .)
    COMMA           reduce using rule 56 (exp -> TRUE .)
    SEMICOLON       reduce using rule 56 (exp -> TRUE .)


state 13

    (58) exp -> FALSE .

    PLUS            reduce using rule 58 (exp -> FALSE .)
    MINUS           reduce using rule 58 (exp -> FALSE .)
    TIMES           reduce using rule 58 (exp -> FALSE .)
    DIVIDE          reduce using rule 58 (exp -> FALSE .)
    EQ              reduce using rule 58 (exp -> FALSE .)
    NOT_EQ          reduce using rule 58 (exp -> FALSE .)
    LT              reduce using rule 58 (exp -> FALSE .)
    GT              reduce using rule 58 (exp -> FALSE .)
    LE              reduce using rule 58 (exp -> FALSE .)
    GE              reduce using rule 58 (exp -> FALSE .)
    AND             reduce using rule 58 (exp -> FALSE .)
    NOT             reduce using rule 58 (exp -> FALSE .)
    $end            reduce using rule 58 (exp -> FALSE .)
    RPAREN          reduce using rule 58 (exp -> FALSE .)
    RBRACKET        reduce using rule 58 (exp -> FALSE .)
    COMMA           reduce using rule 58 (exp -> FALSE .)
    SEMICOLON       reduce using rule 58 (exp -> FALSE .)


state 14

    (59) exp -> NEW . IDENTIFIER LPAREN RPAREN
    (60) exp -> NEW . INT LBRACKET exp RBRACKET
    (61) exp -> NEW . IDENTIFIER LBRACKET exp RBRACKET

    IDENTIFIER      shift and go to state 45
    INT             shift and go to state 46


state 15

    (24) PrimeType -> INT .
    (28) arraytype -> INT . LBRACKET RBRACKET

    LPAREN          reduce using rule 24 (PrimeType -> INT .)
    NUMBER          reduce using rule 24 (PrimeType -> INT .)
    TRUE            reduce using rule 24 (PrimeType -> INT .)
    IDENTIFIER      reduce using rule 24 (PrimeType -> INT .)
    FALSE           reduce using rule 24 (PrimeType -> INT .)
    NEW             reduce using rule 24 (PrimeType -> INT .)
    THIS            reduce using rule 24 (PrimeType -> INT .)
    NOT             reduce using rule 24 (PrimeType -> INT .)
    MINUS           reduce using rule 24 (PrimeType -> INT .)
    INT             reduce using rule 24 (PrimeType -> INT .)
    BOOLEAN         reduce using rule 24 (PrimeType -> INT .)
    VOID            reduce using rule 24 (PrimeType -> INT .)
    LBRACKET        shift and go to state 47


state 16

    (32) Refrence -> THIS .

    LBRACKET        reduce using rule 32 (Refrence -> THIS .)
    LPAREN          reduce using rule 32 (Refrence -> THIS .)
    PLUS            reduce using rule 32 (Refrence -> THIS .)
    MINUS           reduce using rule 32 (Refrence -> THIS .)
    TIMES           reduce using rule 32 (Refrence -> THIS .)
    DIVIDE          reduce using rule 32 (Refrence -> THIS .)
    EQ              reduce using rule 32 (Refrence -> THIS .)
    NOT_EQ          reduce using rule 32 (Refrence -> THIS .)
    LT              reduce using rule 32 (Refrence -> THIS .)
    GT              reduce using rule 32 (Refrence -> THIS .)
    LE              reduce using rule 32 (Refrence -> THIS .)
    GE              reduce using rule 32 (Refrence -> THIS .)
    AND             reduce using rule 32 (Refrence -> THIS .)
    NOT             reduce using rule 32 (Refrence -> THIS .)
    $end            reduce using rule 32 (Refrence -> THIS .)
    RPAREN          reduce using rule 32 (Refrence -> THIS .)
    RBRACKET        reduce using rule 32 (Refrence -> THIS .)
    COMMA           reduce using rule 32 (Refrence -> THIS .)
    SEMICOLON       reduce using rule 32 (Refrence -> THIS .)
    ASSIGN          reduce using rule 32 (Refrence -> THIS .)


state 17

    (21) Type -> PrimeType .

    LPAREN          reduce using rule 21 (Type -> PrimeType .)
    NUMBER          reduce using rule 21 (Type -> PrimeType .)
    TRUE            reduce using rule 21 (Type -> PrimeType .)
    IDENTIFIER      reduce using rule 21 (Type -> PrimeType .)
    FALSE           reduce using rule 21 (Type -> PrimeType .)
    NEW             reduce using rule 21 (Type -> PrimeType .)
    THIS            reduce using rule 21 (Type -> PrimeType .)
    NOT             reduce using rule 21 (Type -> PrimeType .)
    MINUS           reduce using rule 21 (Type -> PrimeType .)
    INT             reduce using rule 21 (Type -> PrimeType .)
    BOOLEAN         reduce using rule 21 (Type -> PrimeType .)
    VOID            reduce using rule 21 (Type -> PrimeType .)


state 18

    (22) Type -> ClassType .
    (29) arraytype -> ClassType . LBRACKET RBRACKET

    LPAREN          reduce using rule 22 (Type -> ClassType .)
    NUMBER          reduce using rule 22 (Type -> ClassType .)
    TRUE            reduce using rule 22 (Type -> ClassType .)
    IDENTIFIER      reduce using rule 22 (Type -> ClassType .)
    FALSE           reduce using rule 22 (Type -> ClassType .)
    NEW             reduce using rule 22 (Type -> ClassType .)
    THIS            reduce using rule 22 (Type -> ClassType .)
    NOT             reduce using rule 22 (Type -> ClassType .)
    MINUS           reduce using rule 22 (Type -> ClassType .)
    INT             reduce using rule 22 (Type -> ClassType .)
    BOOLEAN         reduce using rule 22 (Type -> ClassType .)
    VOID            reduce using rule 22 (Type -> ClassType .)
    LBRACKET        shift and go to state 48


state 19

    (23) Type -> arraytype .

    LPAREN          reduce using rule 23 (Type -> arraytype .)
    NUMBER          reduce using rule 23 (Type -> arraytype .)
    TRUE            reduce using rule 23 (Type -> arraytype .)
    IDENTIFIER      reduce using rule 23 (Type -> arraytype .)
    FALSE           reduce using rule 23 (Type -> arraytype .)
    NEW             reduce using rule 23 (Type -> arraytype .)
    THIS            reduce using rule 23 (Type -> arraytype .)
    NOT             reduce using rule 23 (Type -> arraytype .)
    MINUS           reduce using rule 23 (Type -> arraytype .)
    INT             reduce using rule 23 (Type -> arraytype .)
    BOOLEAN         reduce using rule 23 (Type -> arraytype .)
    VOID            reduce using rule 23 (Type -> arraytype .)


state 20

    (62) Unop -> NOT .

    LPAREN          reduce using rule 62 (Unop -> NOT .)
    NUMBER          reduce using rule 62 (Unop -> NOT .)
    TRUE            reduce using rule 62 (Unop -> NOT .)
    IDENTIFIER      reduce using rule 62 (Unop -> NOT .)
    FALSE           reduce using rule 62 (Unop -> NOT .)
    NEW             reduce using rule 62 (Unop -> NOT .)
    THIS            reduce using rule 62 (Unop -> NOT .)
    NOT             reduce using rule 62 (Unop -> NOT .)
    MINUS           reduce using rule 62 (Unop -> NOT .)
    INT             reduce using rule 62 (Unop -> NOT .)
    BOOLEAN         reduce using rule 62 (Unop -> NOT .)
    VOID            reduce using rule 62 (Unop -> NOT .)


state 21

    (63) Unop -> MINUS .

    LPAREN          reduce using rule 63 (Unop -> MINUS .)
    NUMBER          reduce using rule 63 (Unop -> MINUS .)
    TRUE            reduce using rule 63 (Unop -> MINUS .)
    IDENTIFIER      reduce using rule 63 (Unop -> MINUS .)
    FALSE           reduce using rule 63 (Unop -> MINUS .)
    NEW             reduce using rule 63 (Unop -> MINUS .)
    THIS            reduce using rule 63 (Unop -> MINUS .)
    NOT             reduce using rule 63 (Unop -> MINUS .)
    MINUS           reduce using rule 63 (Unop -> MINUS .)
    INT             reduce using rule 63 (Unop -> MINUS .)
    BOOLEAN         reduce using rule 63 (Unop -> MINUS .)
    VOID            reduce using rule 63 (Unop -> MINUS .)


state 22

    (25) PrimeType -> BOOLEAN .

    LPAREN          reduce using rule 25 (PrimeType -> BOOLEAN .)
    NUMBER          reduce using rule 25 (PrimeType -> BOOLEAN .)
    TRUE            reduce using rule 25 (PrimeType -> BOOLEAN .)
    IDENTIFIER      reduce using rule 25 (PrimeType -> BOOLEAN .)
    FALSE           reduce using rule 25 (PrimeType -> BOOLEAN .)
    NEW             reduce using rule 25 (PrimeType -> BOOLEAN .)
    THIS            reduce using rule 25 (PrimeType -> BOOLEAN .)
    NOT             reduce using rule 25 (PrimeType -> BOOLEAN .)
    MINUS           reduce using rule 25 (PrimeType -> BOOLEAN .)
    INT             reduce using rule 25 (PrimeType -> BOOLEAN .)
    BOOLEAN         reduce using rule 25 (PrimeType -> BOOLEAN .)
    VOID            reduce using rule 25 (PrimeType -> BOOLEAN .)


state 23

    (26) PrimeType -> VOID .

    LPAREN          reduce using rule 26 (PrimeType -> VOID .)
    NUMBER          reduce using rule 26 (PrimeType -> VOID .)
    TRUE            reduce using rule 26 (PrimeType -> VOID .)
    IDENTIFIER      reduce using rule 26 (PrimeType -> VOID .)
    FALSE           reduce using rule 26 (PrimeType -> VOID .)
    NEW             reduce using rule 26 (PrimeType -> VOID .)
    THIS            reduce using rule 26 (PrimeType -> VOID .)
    NOT             reduce using rule 26 (PrimeType -> VOID .)
    MINUS           reduce using rule 26 (PrimeType -> VOID .)
    INT             reduce using rule 26 (PrimeType -> VOID .)
    BOOLEAN         reduce using rule 26 (PrimeType -> VOID .)
    VOID            reduce using rule 26 (PrimeType -> VOID .)


state 24

    (4) start -> ClassDeclaration ClassDeclaration .

    $end            reduce using rule 4 (start -> ClassDeclaration ClassDeclaration .)


state 25

    (53) exp -> exp Binop . exp
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 49
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 26

    (64) Binop -> PLUS .

    LPAREN          reduce using rule 64 (Binop -> PLUS .)
    NUMBER          reduce using rule 64 (Binop -> PLUS .)
    TRUE            reduce using rule 64 (Binop -> PLUS .)
    IDENTIFIER      reduce using rule 64 (Binop -> PLUS .)
    FALSE           reduce using rule 64 (Binop -> PLUS .)
    NEW             reduce using rule 64 (Binop -> PLUS .)
    THIS            reduce using rule 64 (Binop -> PLUS .)
    NOT             reduce using rule 64 (Binop -> PLUS .)
    MINUS           reduce using rule 64 (Binop -> PLUS .)
    INT             reduce using rule 64 (Binop -> PLUS .)
    BOOLEAN         reduce using rule 64 (Binop -> PLUS .)
    VOID            reduce using rule 64 (Binop -> PLUS .)


state 27

    (65) Binop -> MINUS .

    LPAREN          reduce using rule 65 (Binop -> MINUS .)
    NUMBER          reduce using rule 65 (Binop -> MINUS .)
    TRUE            reduce using rule 65 (Binop -> MINUS .)
    IDENTIFIER      reduce using rule 65 (Binop -> MINUS .)
    FALSE           reduce using rule 65 (Binop -> MINUS .)
    NEW             reduce using rule 65 (Binop -> MINUS .)
    THIS            reduce using rule 65 (Binop -> MINUS .)
    NOT             reduce using rule 65 (Binop -> MINUS .)
    MINUS           reduce using rule 65 (Binop -> MINUS .)
    INT             reduce using rule 65 (Binop -> MINUS .)
    BOOLEAN         reduce using rule 65 (Binop -> MINUS .)
    VOID            reduce using rule 65 (Binop -> MINUS .)


state 28

    (66) Binop -> TIMES .

    LPAREN          reduce using rule 66 (Binop -> TIMES .)
    NUMBER          reduce using rule 66 (Binop -> TIMES .)
    TRUE            reduce using rule 66 (Binop -> TIMES .)
    IDENTIFIER      reduce using rule 66 (Binop -> TIMES .)
    FALSE           reduce using rule 66 (Binop -> TIMES .)
    NEW             reduce using rule 66 (Binop -> TIMES .)
    THIS            reduce using rule 66 (Binop -> TIMES .)
    NOT             reduce using rule 66 (Binop -> TIMES .)
    MINUS           reduce using rule 66 (Binop -> TIMES .)
    INT             reduce using rule 66 (Binop -> TIMES .)
    BOOLEAN         reduce using rule 66 (Binop -> TIMES .)
    VOID            reduce using rule 66 (Binop -> TIMES .)


state 29

    (67) Binop -> DIVIDE .

    LPAREN          reduce using rule 67 (Binop -> DIVIDE .)
    NUMBER          reduce using rule 67 (Binop -> DIVIDE .)
    TRUE            reduce using rule 67 (Binop -> DIVIDE .)
    IDENTIFIER      reduce using rule 67 (Binop -> DIVIDE .)
    FALSE           reduce using rule 67 (Binop -> DIVIDE .)
    NEW             reduce using rule 67 (Binop -> DIVIDE .)
    THIS            reduce using rule 67 (Binop -> DIVIDE .)
    NOT             reduce using rule 67 (Binop -> DIVIDE .)
    MINUS           reduce using rule 67 (Binop -> DIVIDE .)
    INT             reduce using rule 67 (Binop -> DIVIDE .)
    BOOLEAN         reduce using rule 67 (Binop -> DIVIDE .)
    VOID            reduce using rule 67 (Binop -> DIVIDE .)


state 30

    (68) Binop -> EQ .

    LPAREN          reduce using rule 68 (Binop -> EQ .)
    NUMBER          reduce using rule 68 (Binop -> EQ .)
    TRUE            reduce using rule 68 (Binop -> EQ .)
    IDENTIFIER      reduce using rule 68 (Binop -> EQ .)
    FALSE           reduce using rule 68 (Binop -> EQ .)
    NEW             reduce using rule 68 (Binop -> EQ .)
    THIS            reduce using rule 68 (Binop -> EQ .)
    NOT             reduce using rule 68 (Binop -> EQ .)
    MINUS           reduce using rule 68 (Binop -> EQ .)
    INT             reduce using rule 68 (Binop -> EQ .)
    BOOLEAN         reduce using rule 68 (Binop -> EQ .)
    VOID            reduce using rule 68 (Binop -> EQ .)


state 31

    (69) Binop -> NOT_EQ .

    LPAREN          reduce using rule 69 (Binop -> NOT_EQ .)
    NUMBER          reduce using rule 69 (Binop -> NOT_EQ .)
    TRUE            reduce using rule 69 (Binop -> NOT_EQ .)
    IDENTIFIER      reduce using rule 69 (Binop -> NOT_EQ .)
    FALSE           reduce using rule 69 (Binop -> NOT_EQ .)
    NEW             reduce using rule 69 (Binop -> NOT_EQ .)
    THIS            reduce using rule 69 (Binop -> NOT_EQ .)
    NOT             reduce using rule 69 (Binop -> NOT_EQ .)
    MINUS           reduce using rule 69 (Binop -> NOT_EQ .)
    INT             reduce using rule 69 (Binop -> NOT_EQ .)
    BOOLEAN         reduce using rule 69 (Binop -> NOT_EQ .)
    VOID            reduce using rule 69 (Binop -> NOT_EQ .)


state 32

    (70) Binop -> LT .

    LPAREN          reduce using rule 70 (Binop -> LT .)
    NUMBER          reduce using rule 70 (Binop -> LT .)
    TRUE            reduce using rule 70 (Binop -> LT .)
    IDENTIFIER      reduce using rule 70 (Binop -> LT .)
    FALSE           reduce using rule 70 (Binop -> LT .)
    NEW             reduce using rule 70 (Binop -> LT .)
    THIS            reduce using rule 70 (Binop -> LT .)
    NOT             reduce using rule 70 (Binop -> LT .)
    MINUS           reduce using rule 70 (Binop -> LT .)
    INT             reduce using rule 70 (Binop -> LT .)
    BOOLEAN         reduce using rule 70 (Binop -> LT .)
    VOID            reduce using rule 70 (Binop -> LT .)


state 33

    (71) Binop -> GT .

    LPAREN          reduce using rule 71 (Binop -> GT .)
    NUMBER          reduce using rule 71 (Binop -> GT .)
    TRUE            reduce using rule 71 (Binop -> GT .)
    IDENTIFIER      reduce using rule 71 (Binop -> GT .)
    FALSE           reduce using rule 71 (Binop -> GT .)
    NEW             reduce using rule 71 (Binop -> GT .)
    THIS            reduce using rule 71 (Binop -> GT .)
    NOT             reduce using rule 71 (Binop -> GT .)
    MINUS           reduce using rule 71 (Binop -> GT .)
    INT             reduce using rule 71 (Binop -> GT .)
    BOOLEAN         reduce using rule 71 (Binop -> GT .)
    VOID            reduce using rule 71 (Binop -> GT .)


state 34

    (72) Binop -> LE .

    LPAREN          reduce using rule 72 (Binop -> LE .)
    NUMBER          reduce using rule 72 (Binop -> LE .)
    TRUE            reduce using rule 72 (Binop -> LE .)
    IDENTIFIER      reduce using rule 72 (Binop -> LE .)
    FALSE           reduce using rule 72 (Binop -> LE .)
    NEW             reduce using rule 72 (Binop -> LE .)
    THIS            reduce using rule 72 (Binop -> LE .)
    NOT             reduce using rule 72 (Binop -> LE .)
    MINUS           reduce using rule 72 (Binop -> LE .)
    INT             reduce using rule 72 (Binop -> LE .)
    BOOLEAN         reduce using rule 72 (Binop -> LE .)
    VOID            reduce using rule 72 (Binop -> LE .)


state 35

    (73) Binop -> GE .

    LPAREN          reduce using rule 73 (Binop -> GE .)
    NUMBER          reduce using rule 73 (Binop -> GE .)
    TRUE            reduce using rule 73 (Binop -> GE .)
    IDENTIFIER      reduce using rule 73 (Binop -> GE .)
    FALSE           reduce using rule 73 (Binop -> GE .)
    NEW             reduce using rule 73 (Binop -> GE .)
    THIS            reduce using rule 73 (Binop -> GE .)
    NOT             reduce using rule 73 (Binop -> GE .)
    MINUS           reduce using rule 73 (Binop -> GE .)
    INT             reduce using rule 73 (Binop -> GE .)
    BOOLEAN         reduce using rule 73 (Binop -> GE .)
    VOID            reduce using rule 73 (Binop -> GE .)


state 36

    (74) Binop -> AND .

    LPAREN          reduce using rule 74 (Binop -> AND .)
    NUMBER          reduce using rule 74 (Binop -> AND .)
    TRUE            reduce using rule 74 (Binop -> AND .)
    IDENTIFIER      reduce using rule 74 (Binop -> AND .)
    FALSE           reduce using rule 74 (Binop -> AND .)
    NEW             reduce using rule 74 (Binop -> AND .)
    THIS            reduce using rule 74 (Binop -> AND .)
    NOT             reduce using rule 74 (Binop -> AND .)
    MINUS           reduce using rule 74 (Binop -> AND .)
    INT             reduce using rule 74 (Binop -> AND .)
    BOOLEAN         reduce using rule 74 (Binop -> AND .)
    VOID            reduce using rule 74 (Binop -> AND .)


state 37

    (75) Binop -> NOT .

    LPAREN          reduce using rule 75 (Binop -> NOT .)
    NUMBER          reduce using rule 75 (Binop -> NOT .)
    TRUE            reduce using rule 75 (Binop -> NOT .)
    IDENTIFIER      reduce using rule 75 (Binop -> NOT .)
    FALSE           reduce using rule 75 (Binop -> NOT .)
    NEW             reduce using rule 75 (Binop -> NOT .)
    THIS            reduce using rule 75 (Binop -> NOT .)
    NOT             reduce using rule 75 (Binop -> NOT .)
    MINUS           reduce using rule 75 (Binop -> NOT .)
    INT             reduce using rule 75 (Binop -> NOT .)
    BOOLEAN         reduce using rule 75 (Binop -> NOT .)
    VOID            reduce using rule 75 (Binop -> NOT .)


state 38

    (5) ClassDeclaration -> CLASS IDENTIFIER . LBRACE RBRACE
    (6) ClassDeclaration -> CLASS IDENTIFIER . LBRACE MethodDeclaration RBRACE
    (7) ClassDeclaration -> CLASS IDENTIFIER . LBRACE FieldDeclaration RBRACE

    LBRACE          shift and go to state 50


state 39

    (57) exp -> IDENTIFIER Binop . NUMBER

    NUMBER          shift and go to state 51


state 40

    (49) exp -> Refrence LBRACKET . exp RBRACKET
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Refrence                       shift and go to state 7
    exp                            shift and go to state 52
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 41

    (50) exp -> Refrence LPAREN . RPAREN
    (51) exp -> Refrence LPAREN . argumentlist RPAREN
    (30) argumentlist -> . exp
    (31) argumentlist -> . exp COMMA exp
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    RPAREN          shift and go to state 53
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Refrence                       shift and go to state 7
    argumentlist                   shift and go to state 54
    exp                            shift and go to state 55
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 42

    (48) exp -> Type exp .
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 48 (exp -> Type exp .)
    RPAREN          reduce using rule 48 (exp -> Type exp .)
    RBRACKET        reduce using rule 48 (exp -> Type exp .)
    COMMA           reduce using rule 48 (exp -> Type exp .)
    SEMICOLON       reduce using rule 48 (exp -> Type exp .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

  ! PLUS            [ reduce using rule 48 (exp -> Type exp .) ]
  ! MINUS           [ reduce using rule 48 (exp -> Type exp .) ]
  ! TIMES           [ reduce using rule 48 (exp -> Type exp .) ]
  ! DIVIDE          [ reduce using rule 48 (exp -> Type exp .) ]
  ! EQ              [ reduce using rule 48 (exp -> Type exp .) ]
  ! NOT_EQ          [ reduce using rule 48 (exp -> Type exp .) ]
  ! LT              [ reduce using rule 48 (exp -> Type exp .) ]
  ! GT              [ reduce using rule 48 (exp -> Type exp .) ]
  ! LE              [ reduce using rule 48 (exp -> Type exp .) ]
  ! GE              [ reduce using rule 48 (exp -> Type exp .) ]
  ! AND             [ reduce using rule 48 (exp -> Type exp .) ]
  ! NOT             [ reduce using rule 48 (exp -> Type exp .) ]

    Binop                          shift and go to state 25

state 43

    (54) exp -> LPAREN exp . RPAREN
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RPAREN          shift and go to state 56
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 44

    (52) exp -> Unop exp .
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 52 (exp -> Unop exp .)
    RPAREN          reduce using rule 52 (exp -> Unop exp .)
    RBRACKET        reduce using rule 52 (exp -> Unop exp .)
    COMMA           reduce using rule 52 (exp -> Unop exp .)
    SEMICOLON       reduce using rule 52 (exp -> Unop exp .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

  ! PLUS            [ reduce using rule 52 (exp -> Unop exp .) ]
  ! MINUS           [ reduce using rule 52 (exp -> Unop exp .) ]
  ! TIMES           [ reduce using rule 52 (exp -> Unop exp .) ]
  ! DIVIDE          [ reduce using rule 52 (exp -> Unop exp .) ]
  ! EQ              [ reduce using rule 52 (exp -> Unop exp .) ]
  ! NOT_EQ          [ reduce using rule 52 (exp -> Unop exp .) ]
  ! LT              [ reduce using rule 52 (exp -> Unop exp .) ]
  ! GT              [ reduce using rule 52 (exp -> Unop exp .) ]
  ! LE              [ reduce using rule 52 (exp -> Unop exp .) ]
  ! GE              [ reduce using rule 52 (exp -> Unop exp .) ]
  ! AND             [ reduce using rule 52 (exp -> Unop exp .) ]
  ! NOT             [ reduce using rule 52 (exp -> Unop exp .) ]

    Binop                          shift and go to state 25

state 45

    (59) exp -> NEW IDENTIFIER . LPAREN RPAREN
    (61) exp -> NEW IDENTIFIER . LBRACKET exp RBRACKET

    LPAREN          shift and go to state 57
    LBRACKET        shift and go to state 58


state 46

    (60) exp -> NEW INT . LBRACKET exp RBRACKET

    LBRACKET        shift and go to state 59


state 47

    (28) arraytype -> INT LBRACKET . RBRACKET

    RBRACKET        shift and go to state 60


state 48

    (29) arraytype -> ClassType LBRACKET . RBRACKET

    RBRACKET        shift and go to state 61


state 49

    (53) exp -> exp Binop exp .
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 53 (exp -> exp Binop exp .)
    RPAREN          reduce using rule 53 (exp -> exp Binop exp .)
    RBRACKET        reduce using rule 53 (exp -> exp Binop exp .)
    COMMA           reduce using rule 53 (exp -> exp Binop exp .)
    SEMICOLON       reduce using rule 53 (exp -> exp Binop exp .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

  ! PLUS            [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! MINUS           [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! TIMES           [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! DIVIDE          [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! EQ              [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! NOT_EQ          [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! LT              [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! GT              [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! LE              [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! GE              [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! AND             [ reduce using rule 53 (exp -> exp Binop exp .) ]
  ! NOT             [ reduce using rule 53 (exp -> exp Binop exp .) ]

    Binop                          shift and go to state 25

state 50

    (5) ClassDeclaration -> CLASS IDENTIFIER LBRACE . RBRACE
    (6) ClassDeclaration -> CLASS IDENTIFIER LBRACE . MethodDeclaration RBRACE
    (7) ClassDeclaration -> CLASS IDENTIFIER LBRACE . FieldDeclaration RBRACE
    (9) MethodDeclaration -> . Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE
    (10) MethodDeclaration -> . Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> . Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> . Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE
    (8) FieldDeclaration -> . Declarators IDENTIFIER SEMICOLON
    (15) Declarators -> . Type
    (16) Declarators -> . STATIC Type
    (17) Declarators -> . PUBLIC Type
    (18) Declarators -> . PRIVATE Type
    (19) Declarators -> . PUBLIC STATIC Type
    (20) Declarators -> . PRIVATE STATIC Type
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    RBRACE          shift and go to state 63
    STATIC          shift and go to state 68
    PUBLIC          shift and go to state 69
    PRIVATE         shift and go to state 70
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    MethodDeclaration              shift and go to state 64
    FieldDeclaration               shift and go to state 65
    Declarators                    shift and go to state 66
    Type                           shift and go to state 67
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 51

    (57) exp -> IDENTIFIER Binop NUMBER .

    PLUS            reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    MINUS           reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    TIMES           reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    DIVIDE          reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    EQ              reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    NOT_EQ          reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    LT              reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    GT              reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    LE              reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    GE              reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    AND             reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    NOT             reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    $end            reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    RPAREN          reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    RBRACKET        reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    COMMA           reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)
    SEMICOLON       reduce using rule 57 (exp -> IDENTIFIER Binop NUMBER .)


state 52

    (49) exp -> Refrence LBRACKET exp . RBRACKET
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RBRACKET        shift and go to state 71
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 53

    (50) exp -> Refrence LPAREN RPAREN .

    PLUS            reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    MINUS           reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    TIMES           reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    DIVIDE          reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    EQ              reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    NOT_EQ          reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    LT              reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    GT              reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    LE              reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    GE              reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    AND             reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    NOT             reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    $end            reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    RPAREN          reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    RBRACKET        reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    COMMA           reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)
    SEMICOLON       reduce using rule 50 (exp -> Refrence LPAREN RPAREN .)


state 54

    (51) exp -> Refrence LPAREN argumentlist . RPAREN

    RPAREN          shift and go to state 72


state 55

    (30) argumentlist -> exp .
    (31) argumentlist -> exp . COMMA exp
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RPAREN          reduce using rule 30 (argumentlist -> exp .)
    COMMA           shift and go to state 73
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 56

    (54) exp -> LPAREN exp RPAREN .

    PLUS            reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    TIMES           reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    EQ              reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    NOT_EQ          reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    LT              reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    GT              reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    LE              reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    GE              reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    NOT             reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    $end            reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 54 (exp -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 54 (exp -> LPAREN exp RPAREN .)


state 57

    (59) exp -> NEW IDENTIFIER LPAREN . RPAREN

    RPAREN          shift and go to state 74


state 58

    (61) exp -> NEW IDENTIFIER LBRACKET . exp RBRACKET
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 75
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 59

    (60) exp -> NEW INT LBRACKET . exp RBRACKET
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 76
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 60

    (28) arraytype -> INT LBRACKET RBRACKET .

    LPAREN          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    NUMBER          reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    TRUE            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    FALSE           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    NEW             reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    THIS            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    NOT             reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    MINUS           reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    INT             reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    BOOLEAN         reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)
    VOID            reduce using rule 28 (arraytype -> INT LBRACKET RBRACKET .)


state 61

    (29) arraytype -> ClassType LBRACKET RBRACKET .

    LPAREN          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    NUMBER          reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    TRUE            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    FALSE           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    NEW             reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    THIS            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    NOT             reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    MINUS           reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    INT             reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    BOOLEAN         reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)
    VOID            reduce using rule 29 (arraytype -> ClassType LBRACKET RBRACKET .)


state 62

    (27) ClassType -> IDENTIFIER .

    LBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (ClassType -> IDENTIFIER .)


state 63

    (5) ClassDeclaration -> CLASS IDENTIFIER LBRACE RBRACE .

    CLASS           reduce using rule 5 (ClassDeclaration -> CLASS IDENTIFIER LBRACE RBRACE .)
    $end            reduce using rule 5 (ClassDeclaration -> CLASS IDENTIFIER LBRACE RBRACE .)


state 64

    (6) ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration . RBRACE

    RBRACE          shift and go to state 77


state 65

    (7) ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration . RBRACE

    RBRACE          shift and go to state 78


state 66

    (9) MethodDeclaration -> Declarators . IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE
    (10) MethodDeclaration -> Declarators . IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators . IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> Declarators . IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE
    (8) FieldDeclaration -> Declarators . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 79


state 67

    (15) Declarators -> Type .

    IDENTIFIER      reduce using rule 15 (Declarators -> Type .)


state 68

    (16) Declarators -> STATIC . Type
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    Type                           shift and go to state 80
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 69

    (17) Declarators -> PUBLIC . Type
    (19) Declarators -> PUBLIC . STATIC Type
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    STATIC          shift and go to state 82
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    Type                           shift and go to state 81
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 70

    (18) Declarators -> PRIVATE . Type
    (20) Declarators -> PRIVATE . STATIC Type
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    STATIC          shift and go to state 84
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    Type                           shift and go to state 83
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 71

    (49) exp -> Refrence LBRACKET exp RBRACKET .

    PLUS            reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    EQ              reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    NOT_EQ          reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    LT              reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    GT              reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    LE              reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    GE              reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    AND             reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    NOT             reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    $end            reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 49 (exp -> Refrence LBRACKET exp RBRACKET .)


state 72

    (51) exp -> Refrence LPAREN argumentlist RPAREN .

    PLUS            reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    MINUS           reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    TIMES           reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    DIVIDE          reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    EQ              reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    NOT_EQ          reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    LT              reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    GT              reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    LE              reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    GE              reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    AND             reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    NOT             reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    $end            reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    RPAREN          reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    RBRACKET        reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    COMMA           reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)
    SEMICOLON       reduce using rule 51 (exp -> Refrence LPAREN argumentlist RPAREN .)


state 73

    (31) argumentlist -> exp COMMA . exp
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 85
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 74

    (59) exp -> NEW IDENTIFIER LPAREN RPAREN .

    PLUS            reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    NOT_EQ          reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    NOT             reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)
    SEMICOLON       reduce using rule 59 (exp -> NEW IDENTIFIER LPAREN RPAREN .)


state 75

    (61) exp -> NEW IDENTIFIER LBRACKET exp . RBRACKET
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RBRACKET        shift and go to state 86
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 76

    (60) exp -> NEW INT LBRACKET exp . RBRACKET
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RBRACKET        shift and go to state 87
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 77

    (6) ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE .

    CLASS           reduce using rule 6 (ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE .)
    $end            reduce using rule 6 (ClassDeclaration -> CLASS IDENTIFIER LBRACE MethodDeclaration RBRACE .)


state 78

    (7) ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE .

    CLASS           reduce using rule 7 (ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE .)
    $end            reduce using rule 7 (ClassDeclaration -> CLASS IDENTIFIER LBRACE FieldDeclaration RBRACE .)


state 79

    (9) MethodDeclaration -> Declarators IDENTIFIER . LPAREN RPAREN LBRACE statement RBRACE
    (10) MethodDeclaration -> Declarators IDENTIFIER . LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER . LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> Declarators IDENTIFIER . LPAREN ParameterList RPAREN LBRACE statement RBRACE
    (8) FieldDeclaration -> Declarators IDENTIFIER . SEMICOLON

    LPAREN          shift and go to state 88
    SEMICOLON       shift and go to state 89


state 80

    (16) Declarators -> STATIC Type .

    IDENTIFIER      reduce using rule 16 (Declarators -> STATIC Type .)


state 81

    (17) Declarators -> PUBLIC Type .

    IDENTIFIER      reduce using rule 17 (Declarators -> PUBLIC Type .)


state 82

    (19) Declarators -> PUBLIC STATIC . Type
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    Type                           shift and go to state 90
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 83

    (18) Declarators -> PRIVATE Type .

    IDENTIFIER      reduce using rule 18 (Declarators -> PRIVATE Type .)


state 84

    (20) Declarators -> PRIVATE STATIC . Type
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    Type                           shift and go to state 91
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 85

    (31) argumentlist -> exp COMMA exp .
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RPAREN          reduce using rule 31 (argumentlist -> exp COMMA exp .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 86

    (61) exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .

    PLUS            reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    EQ              reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    NOT_EQ          reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    LT              reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    GT              reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    LE              reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    GE              reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    AND             reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    NOT             reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    $end            reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 61 (exp -> NEW IDENTIFIER LBRACKET exp RBRACKET .)


state 87

    (60) exp -> NEW INT LBRACKET exp RBRACKET .

    PLUS            reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    TIMES           reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    DIVIDE          reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    EQ              reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    NOT_EQ          reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    LT              reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    GT              reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    LE              reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    GE              reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    AND             reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    NOT             reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    $end            reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 60 (exp -> NEW INT LBRACKET exp RBRACKET .)


state 88

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN . RPAREN LBRACE statement RBRACE
    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN . RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN . ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> Declarators IDENTIFIER LPAREN . ParameterList RPAREN LBRACE statement RBRACE
    (13) ParameterList -> . Type IDENTIFIER
    (14) ParameterList -> . Type IDENTIFIER COMMA Type IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    RPAREN          shift and go to state 92
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    ParameterList                  shift and go to state 93
    Type                           shift and go to state 94
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 89

    (8) FieldDeclaration -> Declarators IDENTIFIER SEMICOLON .

    RBRACE          reduce using rule 8 (FieldDeclaration -> Declarators IDENTIFIER SEMICOLON .)


state 90

    (19) Declarators -> PUBLIC STATIC Type .

    IDENTIFIER      reduce using rule 19 (Declarators -> PUBLIC STATIC Type .)


state 91

    (20) Declarators -> PRIVATE STATIC Type .

    IDENTIFIER      reduce using rule 20 (Declarators -> PRIVATE STATIC Type .)


state 92

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN . LBRACE statement RBRACE
    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN . LBRACE statement RETURN exp SEMICOLON RBRACE

    LBRACE          shift and go to state 95


state 93

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList . RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList . RPAREN LBRACE statement RBRACE

    RPAREN          shift and go to state 96


state 94

    (13) ParameterList -> Type . IDENTIFIER
    (14) ParameterList -> Type . IDENTIFIER COMMA Type IDENTIFIER

    IDENTIFIER      shift and go to state 97


state 95

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE . statement RBRACE
    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE . statement RETURN exp SEMICOLON RBRACE
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    RBRACE          reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 100
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 96

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN . LBRACE statement RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN . LBRACE statement RBRACE

    LBRACE          shift and go to state 108


state 97

    (13) ParameterList -> Type IDENTIFIER .
    (14) ParameterList -> Type IDENTIFIER . COMMA Type IDENTIFIER

    RPAREN          reduce using rule 13 (ParameterList -> Type IDENTIFIER .)
    COMMA           shift and go to state 109


state 98

    (33) Refrence -> IDENTIFIER .
    (27) ClassType -> IDENTIFIER .

  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (ClassType -> IDENTIFIER .)
    LPAREN          reduce using rule 33 (Refrence -> IDENTIFIER .)
    ASSIGN          reduce using rule 33 (Refrence -> IDENTIFIER .)
    LBRACKET        reduce using rule 27 (ClassType -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (ClassType -> IDENTIFIER .)

  ! LBRACKET        [ reduce using rule 33 (Refrence -> IDENTIFIER .) ]


state 99

    (36) statement -> LBRACE . statement RBRACE
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    RBRACE          reduce using rule 76 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 110
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 100

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement . RBRACE
    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement . RETURN exp SEMICOLON RBRACE
    (43) statement -> statement . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          shift and go to state 112
    RETURN          shift and go to state 113
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]
  ! RBRACE          [ reduce using rule 76 (empty -> .) ]
  ! RETURN          [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 111
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 101

    (34) statement -> if_st .

    RBRACE          reduce using rule 34 (statement -> if_st .)
    RETURN          reduce using rule 34 (statement -> if_st .)
    LBRACE          reduce using rule 34 (statement -> if_st .)
    IF              reduce using rule 34 (statement -> if_st .)
    WHILE           reduce using rule 34 (statement -> if_st .)
    THIS            reduce using rule 34 (statement -> if_st .)
    IDENTIFIER      reduce using rule 34 (statement -> if_st .)
    INT             reduce using rule 34 (statement -> if_st .)
    BOOLEAN         reduce using rule 34 (statement -> if_st .)
    VOID            reduce using rule 34 (statement -> if_st .)
    ELSE            reduce using rule 34 (statement -> if_st .)


state 102

    (35) statement -> while_st .

    RBRACE          reduce using rule 35 (statement -> while_st .)
    RETURN          reduce using rule 35 (statement -> while_st .)
    LBRACE          reduce using rule 35 (statement -> while_st .)
    IF              reduce using rule 35 (statement -> while_st .)
    WHILE           reduce using rule 35 (statement -> while_st .)
    THIS            reduce using rule 35 (statement -> while_st .)
    IDENTIFIER      reduce using rule 35 (statement -> while_st .)
    INT             reduce using rule 35 (statement -> while_st .)
    BOOLEAN         reduce using rule 35 (statement -> while_st .)
    VOID            reduce using rule 35 (statement -> while_st .)
    ELSE            reduce using rule 35 (statement -> while_st .)


state 103

    (37) statement -> Refrence . LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> Refrence . LPAREN RPAREN SEMICOLON
    (39) statement -> Refrence . LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> Refrence . ASSIGN exp SEMICOLON

    LPAREN          shift and go to state 114
    LBRACKET        shift and go to state 115
    ASSIGN          shift and go to state 116


state 104

    (41) statement -> Type . IDENTIFIER ASSIGN exp SEMICOLON

    IDENTIFIER      shift and go to state 117


state 105

    (42) statement -> empty .

    RBRACE          reduce using rule 42 (statement -> empty .)
    RETURN          reduce using rule 42 (statement -> empty .)
    LBRACE          reduce using rule 42 (statement -> empty .)
    IF              reduce using rule 42 (statement -> empty .)
    WHILE           reduce using rule 42 (statement -> empty .)
    THIS            reduce using rule 42 (statement -> empty .)
    IDENTIFIER      reduce using rule 42 (statement -> empty .)
    INT             reduce using rule 42 (statement -> empty .)
    BOOLEAN         reduce using rule 42 (statement -> empty .)
    VOID            reduce using rule 42 (statement -> empty .)
    ELSE            reduce using rule 42 (statement -> empty .)


state 106

    (45) if_st -> IF . LPAREN exp RPAREN statement
    (46) if_st -> IF . LPAREN exp RPAREN statement ELSE statement

    LPAREN          shift and go to state 118


state 107

    (44) while_st -> WHILE . LPAREN exp RPAREN statement

    LPAREN          shift and go to state 119


state 108

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE . statement RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE . statement RBRACE
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    RETURN          reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 120
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 109

    (14) ParameterList -> Type IDENTIFIER COMMA . Type IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23
    IDENTIFIER      shift and go to state 62

    Type                           shift and go to state 121
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 110

    (36) statement -> LBRACE statement . RBRACE
    (43) statement -> statement . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          shift and go to state 122
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]
  ! RBRACE          [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 111
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 111

    (43) statement -> statement statement .
    (43) statement -> statement . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for INT resolved using rule 43 (statement -> statement statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 43 (statement -> statement statement .)
  ! reduce/reduce conflict for VOID resolved using rule 43 (statement -> statement statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 43 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 43 (statement -> statement statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 43 (statement -> statement statement .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 43 (statement -> statement statement .)
    RETURN          reduce using rule 43 (statement -> statement statement .)
    ELSE            reduce using rule 43 (statement -> statement statement .)
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 43 (statement -> statement statement .) ]
  ! IF              [ reduce using rule 43 (statement -> statement statement .) ]
  ! WHILE           [ reduce using rule 43 (statement -> statement statement .) ]
  ! THIS            [ reduce using rule 43 (statement -> statement statement .) ]
  ! IDENTIFIER      [ reduce using rule 43 (statement -> statement statement .) ]
  ! INT             [ reduce using rule 43 (statement -> statement statement .) ]
  ! BOOLEAN         [ reduce using rule 43 (statement -> statement statement .) ]
  ! VOID            [ reduce using rule 43 (statement -> statement statement .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]
  ! RBRACE          [ reduce using rule 76 (empty -> .) ]
  ! RETURN          [ reduce using rule 76 (empty -> .) ]
  ! ELSE            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 111
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 112

    (9) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE .

    RBRACE          reduce using rule 9 (MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RBRACE .)


state 113

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN . exp SEMICOLON RBRACE
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 123
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 114

    (37) statement -> Refrence LPAREN . argumentlist RPAREN SEMICOLON
    (38) statement -> Refrence LPAREN . RPAREN SEMICOLON
    (30) argumentlist -> . exp
    (31) argumentlist -> . exp COMMA exp
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    RPAREN          shift and go to state 125
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Refrence                       shift and go to state 7
    argumentlist                   shift and go to state 124
    exp                            shift and go to state 55
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 115

    (39) statement -> Refrence LBRACKET . exp RBRACKET ASSIGN exp SEMICOLON
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Refrence                       shift and go to state 7
    exp                            shift and go to state 126
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 116

    (40) statement -> Refrence ASSIGN . exp SEMICOLON
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Refrence                       shift and go to state 7
    exp                            shift and go to state 127
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 117

    (41) statement -> Type IDENTIFIER . ASSIGN exp SEMICOLON

    ASSIGN          shift and go to state 128


state 118

    (45) if_st -> IF LPAREN . exp RPAREN statement
    (46) if_st -> IF LPAREN . exp RPAREN statement ELSE statement
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 129
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 119

    (44) while_st -> WHILE LPAREN . exp RPAREN statement
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 130
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 120

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement . RETURN exp SEMICOLON RBRACE
    (12) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement . RBRACE
    (43) statement -> statement . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RETURN          shift and go to state 131
    RBRACE          shift and go to state 132
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]
  ! RETURN          [ reduce using rule 76 (empty -> .) ]
  ! RBRACE          [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 111
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 121

    (14) ParameterList -> Type IDENTIFIER COMMA Type . IDENTIFIER

    IDENTIFIER      shift and go to state 133


state 122

    (36) statement -> LBRACE statement RBRACE .

    RBRACE          reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    RETURN          reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    LBRACE          reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    IF              reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    WHILE           reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    THIS            reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    IDENTIFIER      reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    INT             reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    BOOLEAN         reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    VOID            reduce using rule 36 (statement -> LBRACE statement RBRACE .)
    ELSE            reduce using rule 36 (statement -> LBRACE statement RBRACE .)


state 123

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp . SEMICOLON RBRACE
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    SEMICOLON       shift and go to state 134
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 124

    (37) statement -> Refrence LPAREN argumentlist . RPAREN SEMICOLON

    RPAREN          shift and go to state 135


state 125

    (38) statement -> Refrence LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 136


state 126

    (39) statement -> Refrence LBRACKET exp . RBRACKET ASSIGN exp SEMICOLON
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RBRACKET        shift and go to state 137
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 127

    (40) statement -> Refrence ASSIGN exp . SEMICOLON
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    SEMICOLON       shift and go to state 138
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 128

    (41) statement -> Type IDENTIFIER ASSIGN . exp SEMICOLON
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Type                           shift and go to state 8
    exp                            shift and go to state 139
    Refrence                       shift and go to state 7
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 129

    (45) if_st -> IF LPAREN exp . RPAREN statement
    (46) if_st -> IF LPAREN exp . RPAREN statement ELSE statement
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RPAREN          shift and go to state 140
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 130

    (44) while_st -> WHILE LPAREN exp . RPAREN statement
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    RPAREN          shift and go to state 141
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 131

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN . exp SEMICOLON RBRACE
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    exp                            shift and go to state 142
    Refrence                       shift and go to state 7
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 132

    (12) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE .

    RBRACE          reduce using rule 12 (MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RBRACE .)


state 133

    (14) ParameterList -> Type IDENTIFIER COMMA Type IDENTIFIER .

    RPAREN          reduce using rule 14 (ParameterList -> Type IDENTIFIER COMMA Type IDENTIFIER .)


state 134

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON . RBRACE

    RBRACE          shift and go to state 143


state 135

    (37) statement -> Refrence LPAREN argumentlist RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 144


state 136

    (38) statement -> Refrence LPAREN RPAREN SEMICOLON .

    RBRACE          reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    LBRACE          reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    THIS            reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 38 (statement -> Refrence LPAREN RPAREN SEMICOLON .)


state 137

    (39) statement -> Refrence LBRACKET exp RBRACKET . ASSIGN exp SEMICOLON

    ASSIGN          shift and go to state 145


state 138

    (40) statement -> Refrence ASSIGN exp SEMICOLON .

    RBRACE          reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    LBRACE          reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    IF              reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    THIS            reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    INT             reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    BOOLEAN         reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    VOID            reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 40 (statement -> Refrence ASSIGN exp SEMICOLON .)


state 139

    (41) statement -> Type IDENTIFIER ASSIGN exp . SEMICOLON
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    SEMICOLON       shift and go to state 146
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 140

    (45) if_st -> IF LPAREN exp RPAREN . statement
    (46) if_st -> IF LPAREN exp RPAREN . statement ELSE statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    RBRACE          reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 147
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 141

    (44) while_st -> WHILE LPAREN exp RPAREN . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    RBRACE          reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 148
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 142

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp . SEMICOLON RBRACE
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    SEMICOLON       shift and go to state 149
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 143

    (10) MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .

    RBRACE          reduce using rule 10 (MethodDeclaration -> Declarators IDENTIFIER LPAREN RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .)


state 144

    (37) statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .

    RBRACE          reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    RETURN          reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    LBRACE          reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    IF              reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    WHILE           reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    THIS            reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    INT             reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    VOID            reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)
    ELSE            reduce using rule 37 (statement -> Refrence LPAREN argumentlist RPAREN SEMICOLON .)


state 145

    (39) statement -> Refrence LBRACKET exp RBRACKET ASSIGN . exp SEMICOLON
    (47) exp -> . Refrence
    (48) exp -> . Type exp
    (49) exp -> . Refrence LBRACKET exp RBRACKET
    (50) exp -> . Refrence LPAREN RPAREN
    (51) exp -> . Refrence LPAREN argumentlist RPAREN
    (52) exp -> . Unop exp
    (53) exp -> . exp Binop exp
    (54) exp -> . LPAREN exp RPAREN
    (55) exp -> . NUMBER
    (56) exp -> . TRUE
    (57) exp -> . IDENTIFIER Binop NUMBER
    (58) exp -> . FALSE
    (59) exp -> . NEW IDENTIFIER LPAREN RPAREN
    (60) exp -> . NEW INT LBRACKET exp RBRACKET
    (61) exp -> . NEW IDENTIFIER LBRACKET exp RBRACKET
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (62) Unop -> . NOT
    (63) Unop -> . MINUS
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 11
    TRUE            shift and go to state 12
    IDENTIFIER      shift and go to state 6
    FALSE           shift and go to state 13
    NEW             shift and go to state 14
    THIS            shift and go to state 16
    NOT             shift and go to state 20
    MINUS           shift and go to state 21
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

    Refrence                       shift and go to state 7
    exp                            shift and go to state 150
    Type                           shift and go to state 8
    Unop                           shift and go to state 10
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 146

    (41) statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .

    RBRACE          reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    LBRACE          reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    IF              reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    THIS            reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    INT             reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    BOOLEAN         reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    VOID            reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 41 (statement -> Type IDENTIFIER ASSIGN exp SEMICOLON .)


state 147

    (45) if_st -> IF LPAREN exp RPAREN statement .
    (46) if_st -> IF LPAREN exp RPAREN statement . ELSE statement
    (43) statement -> statement . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for INT resolved using rule 45 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 45 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for VOID resolved using rule 45 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 45 (if_st -> IF LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 45 (if_st -> IF LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .)
    RETURN          reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .)
    ELSE            shift and go to state 151
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! IF              [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! WHILE           [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! THIS            [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! IDENTIFIER      [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! INT             [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! BOOLEAN         [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! VOID            [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! ELSE            [ reduce using rule 45 (if_st -> IF LPAREN exp RPAREN statement .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]
  ! RBRACE          [ reduce using rule 76 (empty -> .) ]
  ! RETURN          [ reduce using rule 76 (empty -> .) ]
  ! ELSE            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 111
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 148

    (44) while_st -> WHILE LPAREN exp RPAREN statement .
    (43) statement -> statement . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for INT resolved using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for VOID resolved using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
    RETURN          reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
    ELSE            reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .)
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! IF              [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! WHILE           [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! THIS            [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! IDENTIFIER      [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! INT             [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! BOOLEAN         [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! VOID            [ reduce using rule 44 (while_st -> WHILE LPAREN exp RPAREN statement .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]
  ! RBRACE          [ reduce using rule 76 (empty -> .) ]
  ! RETURN          [ reduce using rule 76 (empty -> .) ]
  ! ELSE            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 111
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 149

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON . RBRACE

    RBRACE          shift and go to state 152


state 150

    (39) statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp . SEMICOLON
    (53) exp -> exp . Binop exp
    (64) Binop -> . PLUS
    (65) Binop -> . MINUS
    (66) Binop -> . TIMES
    (67) Binop -> . DIVIDE
    (68) Binop -> . EQ
    (69) Binop -> . NOT_EQ
    (70) Binop -> . LT
    (71) Binop -> . GT
    (72) Binop -> . LE
    (73) Binop -> . GE
    (74) Binop -> . AND
    (75) Binop -> . NOT

    SEMICOLON       shift and go to state 153
    PLUS            shift and go to state 26
    MINUS           shift and go to state 27
    TIMES           shift and go to state 28
    DIVIDE          shift and go to state 29
    EQ              shift and go to state 30
    NOT_EQ          shift and go to state 31
    LT              shift and go to state 32
    GT              shift and go to state 33
    LE              shift and go to state 34
    GE              shift and go to state 35
    AND             shift and go to state 36
    NOT             shift and go to state 37

    Binop                          shift and go to state 25

state 151

    (46) if_st -> IF LPAREN exp RPAREN statement ELSE . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    RBRACE          reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 154
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19

state 152

    (11) MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .

    RBRACE          reduce using rule 11 (MethodDeclaration -> Declarators IDENTIFIER LPAREN ParameterList RPAREN LBRACE statement RETURN exp SEMICOLON RBRACE .)


state 153

    (39) statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .

    RBRACE          reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    RETURN          reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    LBRACE          reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    IF              reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    THIS            reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    IDENTIFIER      reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    INT             reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    BOOLEAN         reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    VOID            reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)
    ELSE            reduce using rule 39 (statement -> Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON .)


state 154

    (46) if_st -> IF LPAREN exp RPAREN statement ELSE statement .
    (43) statement -> statement . statement
    (34) statement -> . if_st
    (35) statement -> . while_st
    (36) statement -> . LBRACE statement RBRACE
    (37) statement -> . Refrence LPAREN argumentlist RPAREN SEMICOLON
    (38) statement -> . Refrence LPAREN RPAREN SEMICOLON
    (39) statement -> . Refrence LBRACKET exp RBRACKET ASSIGN exp SEMICOLON
    (40) statement -> . Refrence ASSIGN exp SEMICOLON
    (41) statement -> . Type IDENTIFIER ASSIGN exp SEMICOLON
    (42) statement -> . empty
    (43) statement -> . statement statement
    (45) if_st -> . IF LPAREN exp RPAREN statement
    (46) if_st -> . IF LPAREN exp RPAREN statement ELSE statement
    (44) while_st -> . WHILE LPAREN exp RPAREN statement
    (32) Refrence -> . THIS
    (33) Refrence -> . IDENTIFIER
    (21) Type -> . PrimeType
    (22) Type -> . ClassType
    (23) Type -> . arraytype
    (76) empty -> .
    (24) PrimeType -> . INT
    (25) PrimeType -> . BOOLEAN
    (26) PrimeType -> . VOID
    (27) ClassType -> . IDENTIFIER
    (28) arraytype -> . INT LBRACKET RBRACKET
    (29) arraytype -> . ClassType LBRACKET RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for INT resolved using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for VOID resolved using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    RETURN          reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    ELSE            reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .)
    LBRACE          shift and go to state 99
    IF              shift and go to state 106
    WHILE           shift and go to state 107
    THIS            shift and go to state 16
    IDENTIFIER      shift and go to state 98
    INT             shift and go to state 15
    BOOLEAN         shift and go to state 22
    VOID            shift and go to state 23

  ! LBRACE          [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! IF              [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! WHILE           [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! THIS            [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! IDENTIFIER      [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! INT             [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! BOOLEAN         [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! VOID            [ reduce using rule 46 (if_st -> IF LPAREN exp RPAREN statement ELSE statement .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! IF              [ reduce using rule 76 (empty -> .) ]
  ! WHILE           [ reduce using rule 76 (empty -> .) ]
  ! THIS            [ reduce using rule 76 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 76 (empty -> .) ]
  ! INT             [ reduce using rule 76 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 76 (empty -> .) ]
  ! VOID            [ reduce using rule 76 (empty -> .) ]
  ! RBRACE          [ reduce using rule 76 (empty -> .) ]
  ! RETURN          [ reduce using rule 76 (empty -> .) ]
  ! ELSE            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 111
    if_st                          shift and go to state 101
    while_st                       shift and go to state 102
    Refrence                       shift and go to state 103
    Type                           shift and go to state 104
    empty                          shift and go to state 105
    PrimeType                      shift and go to state 17
    ClassType                      shift and go to state 18
    arraytype                      shift and go to state 19
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 6 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 6 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 6 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 6 resolved as shift
WARNING: shift/reduce conflict for EQ in state 6 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 6 resolved as shift
WARNING: shift/reduce conflict for LT in state 6 resolved as shift
WARNING: shift/reduce conflict for GT in state 6 resolved as shift
WARNING: shift/reduce conflict for LE in state 6 resolved as shift
WARNING: shift/reduce conflict for GE in state 6 resolved as shift
WARNING: shift/reduce conflict for AND in state 6 resolved as shift
WARNING: shift/reduce conflict for NOT in state 6 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 42 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 42 resolved as shift
WARNING: shift/reduce conflict for EQ in state 42 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 42 resolved as shift
WARNING: shift/reduce conflict for LT in state 42 resolved as shift
WARNING: shift/reduce conflict for GT in state 42 resolved as shift
WARNING: shift/reduce conflict for LE in state 42 resolved as shift
WARNING: shift/reduce conflict for GE in state 42 resolved as shift
WARNING: shift/reduce conflict for AND in state 42 resolved as shift
WARNING: shift/reduce conflict for NOT in state 42 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 44 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 44 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 44 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 44 resolved as shift
WARNING: shift/reduce conflict for EQ in state 44 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 44 resolved as shift
WARNING: shift/reduce conflict for LT in state 44 resolved as shift
WARNING: shift/reduce conflict for GT in state 44 resolved as shift
WARNING: shift/reduce conflict for LE in state 44 resolved as shift
WARNING: shift/reduce conflict for GE in state 44 resolved as shift
WARNING: shift/reduce conflict for AND in state 44 resolved as shift
WARNING: shift/reduce conflict for NOT in state 44 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 49 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 49 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 49 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 49 resolved as shift
WARNING: shift/reduce conflict for EQ in state 49 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 49 resolved as shift
WARNING: shift/reduce conflict for LT in state 49 resolved as shift
WARNING: shift/reduce conflict for GT in state 49 resolved as shift
WARNING: shift/reduce conflict for LE in state 49 resolved as shift
WARNING: shift/reduce conflict for GE in state 49 resolved as shift
WARNING: shift/reduce conflict for AND in state 49 resolved as shift
WARNING: shift/reduce conflict for NOT in state 49 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 95 resolved as shift
WARNING: shift/reduce conflict for IF in state 95 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 95 resolved as shift
WARNING: shift/reduce conflict for THIS in state 95 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 95 resolved as shift
WARNING: shift/reduce conflict for INT in state 95 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 95 resolved as shift
WARNING: shift/reduce conflict for VOID in state 95 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 99 resolved as shift
WARNING: shift/reduce conflict for IF in state 99 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 99 resolved as shift
WARNING: shift/reduce conflict for THIS in state 99 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 99 resolved as shift
WARNING: shift/reduce conflict for INT in state 99 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 99 resolved as shift
WARNING: shift/reduce conflict for VOID in state 99 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 100 resolved as shift
WARNING: shift/reduce conflict for IF in state 100 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 100 resolved as shift
WARNING: shift/reduce conflict for THIS in state 100 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 100 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 100 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 100 resolved as shift
WARNING: shift/reduce conflict for INT in state 100 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 100 resolved as shift
WARNING: shift/reduce conflict for VOID in state 100 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 108 resolved as shift
WARNING: shift/reduce conflict for IF in state 108 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 108 resolved as shift
WARNING: shift/reduce conflict for THIS in state 108 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 108 resolved as shift
WARNING: shift/reduce conflict for INT in state 108 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 108 resolved as shift
WARNING: shift/reduce conflict for VOID in state 108 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 110 resolved as shift
WARNING: shift/reduce conflict for IF in state 110 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 110 resolved as shift
WARNING: shift/reduce conflict for THIS in state 110 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 110 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 110 resolved as shift
WARNING: shift/reduce conflict for INT in state 110 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 110 resolved as shift
WARNING: shift/reduce conflict for VOID in state 110 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 111 resolved as shift
WARNING: shift/reduce conflict for IF in state 111 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 111 resolved as shift
WARNING: shift/reduce conflict for THIS in state 111 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 111 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 111 resolved as shift
WARNING: shift/reduce conflict for IF in state 111 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 111 resolved as shift
WARNING: shift/reduce conflict for THIS in state 111 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 111 resolved as shift
WARNING: shift/reduce conflict for INT in state 111 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 111 resolved as shift
WARNING: shift/reduce conflict for VOID in state 111 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 120 resolved as shift
WARNING: shift/reduce conflict for IF in state 120 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 120 resolved as shift
WARNING: shift/reduce conflict for THIS in state 120 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 120 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 120 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 120 resolved as shift
WARNING: shift/reduce conflict for INT in state 120 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 120 resolved as shift
WARNING: shift/reduce conflict for VOID in state 120 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 140 resolved as shift
WARNING: shift/reduce conflict for IF in state 140 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 140 resolved as shift
WARNING: shift/reduce conflict for THIS in state 140 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 140 resolved as shift
WARNING: shift/reduce conflict for INT in state 140 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 140 resolved as shift
WARNING: shift/reduce conflict for VOID in state 140 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 141 resolved as shift
WARNING: shift/reduce conflict for IF in state 141 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 141 resolved as shift
WARNING: shift/reduce conflict for THIS in state 141 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 141 resolved as shift
WARNING: shift/reduce conflict for INT in state 141 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 141 resolved as shift
WARNING: shift/reduce conflict for VOID in state 141 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 147 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 147 resolved as shift
WARNING: shift/reduce conflict for IF in state 147 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 147 resolved as shift
WARNING: shift/reduce conflict for THIS in state 147 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 147 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 147 resolved as shift
WARNING: shift/reduce conflict for IF in state 147 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 147 resolved as shift
WARNING: shift/reduce conflict for THIS in state 147 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 147 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 147 resolved as shift
WARNING: shift/reduce conflict for INT in state 147 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 147 resolved as shift
WARNING: shift/reduce conflict for VOID in state 147 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 148 resolved as shift
WARNING: shift/reduce conflict for IF in state 148 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 148 resolved as shift
WARNING: shift/reduce conflict for THIS in state 148 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 148 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 148 resolved as shift
WARNING: shift/reduce conflict for IF in state 148 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 148 resolved as shift
WARNING: shift/reduce conflict for THIS in state 148 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 148 resolved as shift
WARNING: shift/reduce conflict for INT in state 148 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 148 resolved as shift
WARNING: shift/reduce conflict for VOID in state 148 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 151 resolved as shift
WARNING: shift/reduce conflict for IF in state 151 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 151 resolved as shift
WARNING: shift/reduce conflict for THIS in state 151 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 151 resolved as shift
WARNING: shift/reduce conflict for INT in state 151 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 151 resolved as shift
WARNING: shift/reduce conflict for VOID in state 151 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 154 resolved as shift
WARNING: shift/reduce conflict for IF in state 154 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 154 resolved as shift
WARNING: shift/reduce conflict for THIS in state 154 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 154 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 154 resolved as shift
WARNING: shift/reduce conflict for IF in state 154 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 154 resolved as shift
WARNING: shift/reduce conflict for THIS in state 154 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 154 resolved as shift
WARNING: shift/reduce conflict for INT in state 154 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 154 resolved as shift
WARNING: shift/reduce conflict for VOID in state 154 resolved as shift
WARNING: reduce/reduce conflict in state 6 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (Refrence -> IDENTIFIER) in state 6
WARNING: reduce/reduce conflict in state 98 resolved using rule (ClassType -> IDENTIFIER)
WARNING: rejected rule (Refrence -> IDENTIFIER) in state 98
WARNING: reduce/reduce conflict in state 111 resolved using rule (statement -> statement statement)
WARNING: rejected rule (empty -> <empty>) in state 111
WARNING: reduce/reduce conflict in state 147 resolved using rule (if_st -> IF LPAREN exp RPAREN statement)
WARNING: rejected rule (empty -> <empty>) in state 147
WARNING: reduce/reduce conflict in state 148 resolved using rule (while_st -> WHILE LPAREN exp RPAREN statement)
WARNING: rejected rule (empty -> <empty>) in state 148
WARNING: reduce/reduce conflict in state 154 resolved using rule (if_st -> IF LPAREN exp RPAREN statement ELSE statement)
WARNING: rejected rule (empty -> <empty>) in state 154
